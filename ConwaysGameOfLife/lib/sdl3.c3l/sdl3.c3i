module sdl3;

distinct SpinLock = int;

macro @atomic_dec_ref(&a) => atomic_add(&a, -1) == 1;
macro @atomic_inc_ref(&a) => atomic_add(&a, 1);

struct AtomicInt
{
    int value;
}

fn int atomic_add(AtomicInt* a, int v) @extern("SDL_AtomicAdd");
fn bool atomic_compare_and_swap(AtomicInt* a, int oldval, int newval) @extern("SDL_AtomicCompareAndSwap");
fn bool atomic_compare_and_swap_pointer(void** a, void* oldval, void* newval) @extern("SDL_AtomicCompareAndSwapPointer");
fn int atomic_get(AtomicInt* a) @extern("SDL_AtomicGet");
fn void* atomic_get_ptr(void** a) @extern("SDL_AtomicGetPtr");
fn int atomic_set(AtomicInt* a, int v) @extern("SDL_AtomicSet");
fn void* atomic_set_ptr(void** a, void* v) @extern("SDL_AtomicSetPtr");
fn void lock_spinlock(SpinLock* lock) @extern("SDL_LockSpinlock");
fn void memory_barrier_acquire_function() @extern("SDL_MemoryBarrierAcquireFunction");
fn void memory_barrier_release_function() @extern("SDL_MemoryBarrierReleaseFunction");
fn bool try_lock_spinlock(SpinLock* lock) @extern("SDL_TryLockSpinlock");
fn void unlock_spinlock(SpinLock* lock) @extern("SDL_UnlockSpinlock");

module sdl3;

const uint AUDIO_MASK_BITSIZE     =  (0xFFu);
const uint AUDIO_MASK_FLOAT       =  (1u<<8);
const uint AUDIO_MASK_BIG_ENDIAN  =  (1u<<12);
const uint AUDIO_MASK_SIGNED      =  (1u<<15);

macro @audio_bitsize(&x)  => ((&x) & AUDIO_MASK_BITSIZE);
macro @audio_bytesize(&x) => (@audio_bitsize(&x) / 8);
macro @audio_is_float(&x) => ((&x) &  AUDIO_MASK_FLOAT);
macro @audio_is_bigendian(&x) => ((&x) & AUDIO_MASK_BIG_ENDIAN);
macro @audio_is_little_endian(&x) => (!@audio_is_big_endian(&x));
macro @audio_is_signed(&x) => ((&x) & AUDIO_MASK_SIGNED);
macro @audio_is_int(&x) => (!@audio_is_float(&x));
macro @audio_is_unsigned(&x) => (!@audio_is_signed(&x));

distinct AudioDeviceID = uint;
distinct AudioFormat = uint;
distinct AudioStream = void*;

def AudioPostmixCallback = fn void(void* userdata, AudioSpec* spec, float* buffer, int buflen);
def AudioStreamCallback = fn void(void* userdata,  AudioStream* stream, int additional_amount, int total_amount);

struct AudioSpec
{
    AudioFormat format;
    int channels;
    int freq;
}

fn int _convert_audio_samples(AudioSpec* src_spec, ZString src_data, int src_len, AudioSpec* dst_spec, char** dst_data, int* dst_len) @extern("SDL_ConvertAudioSamples");
fn int _load_wav(ZString path, AudioSpec* spec, char** audio_buf, uint* audio_len) @extern("SDL_LoadWAV");
fn int _load_wav_io(IOStream* src, bool closeio, AudioSpec* spec, char** audio_buf, uint* audio_len) @extern("SDL_LoadWAV_IO");

macro int convert_audio_samples(AudioSpec* src_spec, ZString src_data, AudioSpec* dst_spec, ZString[] dst_data)
{
    int dst_len;
    return _convert_audio_samples(src_spec, src_data, src_data.len(), dst_spec, (char**)dst_data, &dst_len);
}

macro int load_wav(ZString path, AudioSpec* spec, ZString[] audio_buf)
{
    uint audio_len;
    return _load_wav(path, spec, (char**)audio_buf, &audio_len);
}


macro int load_wav_io(IOStream* src, bool closeio, AudioSpec* spec, char** audio_buf)
{
    uint audio_len;
    return _load_wav_io(src, closeio, spec, (char**)audio_buf, audio_len);
}


fn bool audio_device_paused(AudioDeviceID dev) @extern("SDL_AudioDevicePaused");
fn int bind_audio_stream(AudioDeviceID devid, AudioStream* stream) @extern("SDL_BindAudioStream");
fn int bind_audio_streams(AudioDeviceID devid, AudioStream** streams, int num_streams) @extern("SDL_BindAudioStreams");
fn int clear_audio_stream(AudioStream* stream) @extern("SDL_ClearAudioStream");
fn void close_audio_device(AudioDeviceID devid) @extern("SDL_CloseAudioDevice");
fn AudioStream* create_audio_stream(AudioSpec* src_spec, AudioSpec* dst_spec) @extern("SDL_CreateAudioStream");
fn void destroy_audio_stream(AudioStream* stream) @extern("SDL_DestroyAudioStream");
fn int flush_audio_stream(AudioStream* stream) @extern("SDL_FlushAudioStream");
fn int* get_audio_device_channel_map(AudioDeviceID devid, int* count) @extern("SDL_GetAudioDeviceChannelMap");
fn int get_audio_device_format(AudioDeviceID devid, AudioSpec* spec, int* sample_frames) @extern("SDL_GetAudioDeviceFormat");
fn float get_audio_device_gain(AudioDeviceID devid) @extern("SDL_GetAudioDeviceGain");
fn ZString get_audio_device_name(AudioDeviceID devid) @extern("SDL_GetAudioDeviceName");
fn ZString get_audio_driver(int index) @extern("SDL_GetAudioDriver");
fn ZString get_audio_format_name(AudioFormat format) @extern("SDL_GetAudioFormatName");
fn AudioDeviceID* get_audio_playback_devices(int* count) @extern("SDL_GetAudioPlaybackDevices");
fn AudioDeviceID* get_audio_recording_devices(int* count) @extern("SDL_GetAudioRecordingDevices");
fn int get_audio_stream_available(AudioStream* stream) @extern("SDL_GetAudioStreamAvailable");
fn int get_audio_stream_data(AudioStream* stream, void* buf, int len) @extern("SDL_GetAudioStreamData");
fn AudioDeviceID get_audio_stream_device(AudioStream* stream) @extern("SDL_GetAudioStreamDevice");
fn int get_audio_stream_format(AudioStream* stream, AudioSpec* src_spec, AudioSpec* dst_spec) @extern("SDL_GetAudioStreamFormat");
fn float get_audio_stream_frequency_ratio(AudioStream* stream) @extern("SDL_GetAudioStreamFrequencyRatio");
fn float get_audio_stream_gain(AudioStream* stream) @extern("SDL_GetAudioStreamGain");
fn int* get_audio_stream_input_channel_map(AudioStream* stream, int* count) @extern("SDL_GetAudioStreamInputChannelMap");
fn int* get_audio_stream_output_channel_map(AudioStream* stream, int* count) @extern("SDL_GetAudioStreamOutputChannelMap");
fn PropertiesID get_audio_stream_properties(AudioStream* stream) @extern("SDL_GetAudioStreamProperties");
fn int get_audio_stream_queued(AudioStream* stream) @extern("SDL_GetAudioStreamQueued");
fn ZString get_current_audio_driver() @extern("SDL_GetCurrentAudioDriver");
fn int get_num_audio_drivers() @extern("SDL_GetNumAudioDrivers");
fn int get_silence_value_for_format(AudioFormat format) @extern("SDL_GetSilenceValueForFormat");
fn int lock_audio_stream(AudioStream* stream) @extern("SDL_LockAudioStream");
fn int mix_audio(ZString dst, ZString src, AudioFormat format, uint len, float volume) @extern("SDL_MixAudio");
fn AudioDeviceID open_audio_device(AudioDeviceID devid, AudioSpec* spec) @extern("SDL_OpenAudioDevice");
fn AudioStream* open_audio_device_stream(AudioDeviceID devid, AudioSpec* spec, AudioStreamCallback callback, void* userdata) @extern("SDL_OpenAudioDeviceStream");
fn int pause_audio_device(AudioDeviceID dev) @extern("SDL_PauseAudioDevice");
fn int pause_audio_stream_device(AudioStream* stream) @extern("SDL_PauseAudioStreamDevice");
fn int put_audio_stream_data(AudioStream* stream, void* buf, int len) @extern("SDL_PutAudioStreamData");
fn int resume_audio_device(AudioDeviceID dev) @extern("SDL_ResumeAudioDevice");
fn int resume_audio_stream_device(AudioStream* stream) @extern("SDL_ResumeAudioStreamDevice");
fn int set_audio_device_gain(AudioDeviceID devid, float gain) @extern("SDL_SetAudioDeviceGain");
fn int set_audio_postmix_callback(AudioDeviceID devid, AudioPostmixCallback callback, void* userdata) @extern("SDL_SetAudioPostmixCallback");
fn int set_audio_stream_format(AudioStream* stream, AudioSpec* src_spec, AudioSpec* dst_spec) @extern("SDL_SetAudioStreamFormat");
fn int set_audio_stream_frequency_ratio(AudioStream* stream, float ratio) @extern("SDL_SetAudioStreamFrequencyRatio");
fn int set_audio_stream_gain(AudioStream* stream, float gain) @extern("SDL_SetAudioStreamGain");
fn int set_audio_stream_get_callback(AudioStream* stream, AudioStreamCallback callback, void* userdata) @extern("SDL_SetAudioStreamGetCallback");
fn int set_audio_stream_input_channel_map(AudioStream* stream, int* chmap, int count) @extern("SDL_SetAudioStreamInputChannelMap");
fn int set_audio_stream_output_channel_map(AudioStream* stream, int* chmap, int count) @extern("SDL_SetAudioStreamOutputChannelMap");
fn int set_audio_stream_put_callback(AudioStream* stream, AudioStreamCallback callback, void* userdata) @extern("SDL_SetAudioStreamPutCallback");
fn void unbind_audio_stream(AudioStream* stream) @extern("SDL_UnbindAudioStream");
fn void unbind_audio_streams(AudioStream** streams, int num_streams) @extern("SDL_UnbindAudioStreams");
fn int unlock_audio_stream(AudioStream* stream) @extern("SDL_UnlockAudioStream");

module sdl3::audio_format;

const AudioFormat U8     =  0x0008u;
const AudioFormat S8     =  0x8008u;
const AudioFormat S16LE  =  0x8010u;
const AudioFormat S16BE  =  0x9010u;
const AudioFormat S32LE  =  0x8020u;
const AudioFormat S32BE  =  0x9020u;
const AudioFormat F32LE  =  0x8120u;
const AudioFormat F32BE  =  0x9120u;

module sdl3;

distinct BlendFactor = uint;
distinct BlendMode = uint;
distinct BlendOperation = uint;

fn BlendMode compose_custom_blend_mode(BlendFactor src_cf, BlendFactor dst_cf, BlendOperation color_op, BlendFactor src_af, BlendFactor dst_af, BlendOperation alpha_op) @extern("SDL_ComposeCustomBlendMode");

module sdl3::blend_factor;

const BlendFactor ZERO                 =  0x1;
const BlendFactor ONE                  =  0x2;
const BlendFactor SRC_COLOR            =  0x3;
const BlendFactor ONE_MINUS_SRC_COLOR  =  0x4;
const BlendFactor SRC_ALPHA            =  0x5;
const BlendFactor ONE_MINUS_SRC_ALPHA  =  0x6;
const BlendFactor DST_COLOR            =  0x7;
const BlendFactor ONE_MINUS_DST_COLOR  =  0x8;
const BlendFactor DST_ALPHA            =  0x9;
const BlendFactor ONE_MINUS_DST_ALPHA  =  0xA;

module sdl3::blend_mode;

const BlendMode NONE                 =  0x00000000u;
const BlendMode BLEND                =  0x00000001u;
const BlendMode BLEND_PREMULTIPLIED  =  0x00000010u;
const BlendMode ADD                  =  0x00000002u;
const BlendMode ADD_PREMULTIPLIED    =  0x00000020u;
const BlendMode MOD                  =  0x00000004u;
const BlendMode MUL                  =  0x00000008u;
const BlendMode INVALID              =  0x7FFFFFFFu;

module sdl3::blend_operation;

const BlendOperation ADD           =  0x1;
const BlendOperation SUBTRACT      =  0x2;
const BlendOperation REV_SUBTRACT  =  0x3;
const BlendOperation MINIMUM       =  0x4;
const BlendOperation MAXIMUM       =  0x5;

module sdl3;

distinct Camera = void*;
distinct CameraID = uint;
distinct CameraPosition = uint;

struct CameraSpec
{
    PixelFormat format;
    Colorspace colorspace;
    int width;
    int height;
    int framerate_numerator;
    int framerate_denominator;
}

fn Surface* acquire_camera_frame(Camera* camera, ulong* timestampNS) @extern("SDL_AcquireCameraFrame");
fn void close_camera(Camera* camera) @extern("SDL_CloseCamera");
fn ZString get_camera_driver(int index) @extern("SDL_GetCameraDriver");
fn int get_camera_format(Camera* camera, CameraSpec* spec) @extern("SDL_GetCameraFormat");
fn CameraID get_camera_id(Camera* camera) @extern("SDL_GetCameraID");
fn ZString get_camera_name(CameraID instance_id) @extern("SDL_GetCameraName");
fn int get_camera_permission_state(Camera* camera) @extern("SDL_GetCameraPermissionState");
fn CameraPosition  get_camera_position(CameraID instance_id) @extern("SDL_GetCameraPosition");
fn PropertiesID get_camera_properties(Camera* camera) @extern("SDL_GetCameraProperties");
fn CameraID* get_cameras(int* count) @extern("SDL_GetCameras");

fn CameraSpec** _get_camera_supported_formats(CameraID devid, int* count) @extern("SDL_GetCameraSupportedFormats") @local;

macro CameraSpec[] get_camera_supported_formats(CameraID devid)
{
    int count;
    CameraSpec** _formats = _get_camera_supported_formats(devid, &count);

    CameraSpec[] formats = mem::new_array(CameraSpec, count);
    for (int i = 0; i < count; ++i) formats[i] = (CameraSpec)*_formats[i];
    return formats;
}

fn ZString get_current_camera_driver() @extern("SDL_GetCurrentCameraDriver");
fn int get_num_camera_drivers() @extern("SDL_GetNumCameraDrivers");
fn Camera* open_camera(CameraID instance_id, CameraSpec* spec) @extern("SDL_OpenCamera");
fn int release_camera_frame(Camera* camera, Surface* frame) @extern("SDL_ReleaseCameraFrame");

module sdl3::camera_position;

const CameraPosition UNKNOWN       =  0;
const CameraPosition FRONT_FACING  =  1;
const CameraPosition BACK_FACING   =  2;

module sdl3;

def ClipboardCleanupCallback = fn void(void* userdata);
def ClipboardDataCallback = fn void*(void* userdata, ZString mime_type, usz* size);

fn int clear_clipboard_data() @extern("SDL_ClearClipboardData");
fn void* get_clipboard_data(ZString mime_type, usz* size) @extern("SDL_GetClipboardData");
fn ZString get_clipboard_text() @extern("SDL_GetClipboardText");
fn ZString get_primary_selection_text() @extern("SDL_GetPrimarySelectionText");
fn bool has_clipboard_data(ZString mime_type) @extern("SDL_HasClipboardData");
fn bool has_clipboard_text() @extern("SDL_HasClipboardText");
fn bool has_primary_selection_text() @extern("SDL_HasPrimarySelectionText");
fn int set_clipboard_data(ClipboardDataCallback callback, ClipboardCleanupCallback cleanup, void* userdata, char** mime_types, usz num_mime_types) @extern("SDL_SetClipboardData");
fn int set_clipboard_text(ZString text) @extern("SDL_SetClipboardText");
fn int set_primary_selection_text(ZString text) @extern("SDL_SetPrimarySelectionText");

module sdl3;

const uint CACHELINE_SIZE  =  128;

fn int get_cpu_cache_line_size() @extern("SDL_GetCPUCacheLineSize");
fn int get_cpu_count() @extern("SDL_GetCPUCount");
fn usz get_simd_alignment() @extern("SDL_GetSIMDAlignment");
fn int get_system_ram() @extern("SDL_GetSystemRAM");
fn bool has_alti_vec() @extern("SDL_HasAltiVec");
fn bool has_armsimd() @extern("SDL_HasARMSIMD");
fn bool has_avx() @extern("SDL_HasAVX");
fn bool has_avx2() @extern("SDL_HasAVX2");
fn bool has_avx512f() @extern("SDL_HasAVX512F");
fn bool has_lasx() @extern("SDL_HasLASX");
fn bool has_lsx() @extern("SDL_HasLSX");
fn bool has_mmx() @extern("SDL_HasMMX");
fn bool has_neon() @extern("SDL_HasNEON");
fn bool has_sse() @extern("SDL_HasSSE");
fn bool has_sse2() @extern("SDL_HasSSE2");
fn bool has_sse3() @extern("SDL_HasSSE3");
fn bool has_sse41() @extern("SDL_HasSSE41");
fn bool has_sse42() @extern("SDL_HasSSE42");

module sdl3;

def DialogFileCallback = fn void(void* userdata, ZString* filelist, int filter);

struct DialogFileFilter
{
    ZString name;
    ZString pattern;
}

fn void show_open_file_dialog(DialogFileCallback callback, void* userdata, Window* window, DialogFileFilter* filters, int nfilters, ZString default_location, bool allow_many) @extern("SDL_ShowOpenFileDialog");
fn void show_open_folder_dialog(DialogFileCallback callback, void* userdata, Window* window, ZString default_location, bool allow_many) @extern("SDL_ShowOpenFolderDialog");
fn void show_save_file_dialog(DialogFileCallback callback, void* userdata, Window* window, DialogFileFilter* filters, int nfilters, ZString default_location) @extern("SDL_ShowSaveFileDialog");

module sdl3;

fn ZString get_error() @extern("SDL_GetError");
fn int clear_error() @extern("SDL_ClearError");
fn int out_of_memory() @extern("SDL_OutOfMemory");
fn int set_error(ZString fmt, ...) @extern("SDL_SetError");

module sdl3;

distinct EventAction = uint;
distinct EventType = uint;

def EventFilter = fn bool(void* userdata, Event* event);

distinct Keysym = uint;

fn int add_event_watch(EventFilter filter, void* userdata) @extern("SDL_AddEventWatch");
fn void del_event_watch(EventFilter filter, void* userdata) @extern("SDL_DelEventWatch");
fn bool event_enabled(uint type) @extern("SDL_EventEnabled");
fn void filter_events(EventFilter filter, void* userdata) @extern("SDL_FilterEvents");
fn void flush_event(uint type) @extern("SDL_FlushEvent");
fn void flush_events(uint minType, uint maxType) @extern("SDL_FlushEvents");
fn bool get_event_filter(EventFilter* filter, void** userdata) @extern("SDL_GetEventFilter");
fn Window* get_window_from_event(Event* event) @extern("SDL_GetWindowFromEvent");
fn bool has_event(uint type) @extern("SDL_HasEvent");
fn bool has_events(uint minType, uint maxType) @extern("SDL_HasEvents");
fn int peep_events(Event* events, int numevents, EventAction action, uint minType, uint maxType) @extern("SDL_PeepEvents");
fn bool poll_event(Event* event) @extern("SDL_PollEvent");
fn void pump_events() @extern("SDL_PumpEvents");
fn int push_event(Event* event) @extern("SDL_PushEvent");
fn uint register_events(int numevents) @extern("SDL_RegisterEvents");
fn void set_event_enabled(uint type, bool enabled) @extern("SDL_SetEventEnabled");
fn void set_event_filter(EventFilter filter, void* userdata) @extern("SDL_SetEventFilter");
fn bool wait_event(Event* event) @extern("SDL_WaitEvent");
fn bool wait_event_timeout(Event* event, int timeoutMS) @extern("SDL_WaitEventTimeout");

struct AudioDeviceEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    AudioDeviceID which;
    char recording;
    char padding1;
    char padding2;
    char padding3;
}

struct CameraDeviceEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    CameraID which;
}

struct ClipboardEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
}

struct CommonEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
}

struct DisplayEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    DisplayID displayID;
    int data1;
    int data2;
}

struct DropEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    float x;
    float y;
    ZString source;
    ZString data;
}

struct GamepadAxisEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    char axis;
    char padding1;
    char padding2;
    char padding3;
    short  value;
    ushort padding4;
}

struct GamepadButtonEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    char button;
    char state;
    char padding1;
    char padding2;
}

struct GamepadDeviceEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
}

struct GamepadSensorEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    int sensor;
    float[3] data;
    ulong sensor_timestamp;
}

struct GamepadTouchpadEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    int touchpad;
    int finger;
    float x;
    float y;
    float pressure;
}

struct JoyAxisEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    char axis;
    char padding1;
    char padding2;
    char padding3;
    short value;
    ushort padding4;
}

struct JoyBallEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    char ball;
    char padding1;
    char padding2;
    char padding3;
    short xrel;
    short yrel;
}

struct JoyBatteryEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    PowerState state;
    int percent;
}

struct JoyButtonEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    char button;
    char state;
    char padding1;
    char padding2;
}

struct JoyDeviceEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
}

struct JoyHatEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    JoystickID which;
    char hat;
    char value;
    char padding1;
    char padding2;
}

struct KeyboardDeviceEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    KeyboardID which;
}

struct KeyboardEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    KeyboardID which;
    Scancode scancode;
    Keycode key;
    Keymod mod;
    ushort raw;
    char state;
    char repeat;
}

struct MouseButtonEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    MouseID which;
    char button;
    char state;
    char clicks;
    char padding;
    float x;
    float y;
}

struct MouseDeviceEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    MouseID which;
}

struct MouseMotionEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    MouseID which;
    MouseButtonFlags state;
    float x;
    float y;
    float xrel;
    float yrel;
}

struct MouseWheelEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    MouseID which;
    float x;
    float y;
    MouseWheelDirection direction;
    float mouse_x;
    float mouse_y;
}

struct PenAxisEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    PenID which;
    PenInputFlags pen_state;
    float x;
    float y;
    PenAxis axis;
    float value;
}

struct PenButtonEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    PenID which;
    PenInputFlags pen_state;
    float x;
    float y;
    char button;
    char state;
}

struct PenMotionEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    PenID which;
    PenInputFlags pen_state;
    float x;
    float y;
}

struct PenProximityEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    PenID which;
}

struct PenTouchEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    PenID which;
    PenInputFlags pen_state;
    float x;
    float y;
    char eraser;
    char state;
}

struct QuitEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
}

struct SensorEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    SensorID which;
    float[6] data;
    ulong sensor_timestamp;
}

struct TextEditingCandidatesEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    char** candidates;
    int num_candidates;
    int selected_candidate;
    bool horizontal;
}

struct TextEditingEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    ZString text;
    int start;
    int length;
}

struct TextInputEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    char data;
}

struct TouchFingerEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    TouchID touchID;
    FingerID fingerID;
    float x;
    float y;
    float dx;
    float dy;
    float pressure;
    WindowID windowID;
}

struct UserEvent
{
    uint type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    int code;
    void* data1;
    void* data2;
}

struct WindowEvent
{
    EventType type;
    uint reserved;
    ulong timestamp;
    WindowID windowID;
    int data1;
    int data2;
}

union Event
{
    EventType type;
    CommonEvent common;
    DisplayEvent display;
    WindowEvent window;
    KeyboardDeviceEvent kdevice;
    KeyboardEvent keyboard;
    TextEditingEvent edit;
    TextEditingCandidatesEvent edit_candidates;
    TextInputEvent text;
    MouseDeviceEvent mdevice;
    MouseMotionEvent motion;
    MouseButtonEvent mouse;
    MouseWheelEvent wheel;
    JoyDeviceEvent jdevice;
    JoyAxisEvent jaxis;
    JoyBallEvent jball;
    JoyHatEvent jhat;
    JoyButtonEvent jbutton;
    JoyBatteryEvent jbattery;
    GamepadDeviceEvent gdevice;
    GamepadAxisEvent gaxis;
    GamepadButtonEvent gbutton;
    GamepadTouchpadEvent gtouchpad;
    GamepadSensorEvent gsensor;
    AudioDeviceEvent adevice;
    CameraDeviceEvent cdevice;
    SensorEvent sensor;
    QuitEvent quit;
    UserEvent user;
    TouchFingerEvent tfinger;
    PenProximityEvent pproximity;
    PenTouchEvent ptouch;
    PenMotionEvent pmotion;
    PenButtonEvent pbutton;
    PenAxisEvent paxis;
    DropEvent drop;
    ClipboardEvent clipboard;
    
    char[128] padding; 
}

module sdl3::event_action;

const EventAction ADDEVENT   =  0;
const EventAction PEEKEVENT  =  1;
const EventAction GETEVENT   =  2;

module sdl3::event_type;

const EventType FIRST                         =  0x0;
const EventType QUIT                          =  0x100;
const EventType TERMINATING                   =  0x101;
const EventType LOW_MEMORY                    =  0x102;
const EventType WILL_ENTER_BACKGROUND         =  0x103;
const EventType DID_ENTER_BACKGROUND          =  0x104;
const EventType WILL_ENTER_FOREGROUND         =  0x105;
const EventType DID_ENTER_FOREGROUND          =  0x106;
const EventType LOCALE_CHANGED                =  0x107;
const EventType SYSTEM_THEME_CHANGED          =  0x108;
const EventType DISPLAY_ORIENTATION           =  0x151;
const EventType DISPLAY_ADDED                 =  0x152;
const EventType DISPLAY_REMOVED               =  0x153;
const EventType DISPLAY_MOVED                 =  0x154;
const EventType DISPLAY_DESKTOP_MODE_CHANGED  =  0x155;
const EventType DISPLAY_CURRENT_MODE_CHANGED  =  0x156;
const EventType DISPLAY_CONTENT_SCALE_CHANGED =  0x157;
const EventType DISPLAY_FIRST                 =  0x151;
const EventType DISPLAY_LAST                  =  0x157;
const EventType WINDOW_SHOWN                  =  0x202;
const EventType WINDOW_HIDDEN                 =  0x203;
const EventType WINDOW_EXPOSED                =  0x204;
const EventType WINDOW_MOVED                  =  0x205;
const EventType WINDOW_RESIZED                =  0x206;
const EventType WINDOW_PIXEL_SIZE_CHANGED     =  0x207;
const EventType WINDOW_METAL_VIEW_RESIZED     =  0x208;
const EventType WINDOW_MINIMIZED              =  0x209;
const EventType WINDOW_MAXIMIZED              =  0x20a;
const EventType WINDOW_RESTORED               =  0x20b;
const EventType WINDOW_MOUSE_ENTER            =  0x20c;
const EventType WINDOW_MOUSE_LEAVE            =  0x20d;
const EventType WINDOW_FOCUS_GAINED           =  0x20e;
const EventType WINDOW_FOCUS_LOST             =  0x20f;
const EventType WINDOW_CLOSE_REQUESTED        =  0x210;
const EventType WINDOW_HIT_TEST               =  0x211;
const EventType WINDOW_ICCPROF_CHANGED        =  0x212;
const EventType WINDOW_DISPLAY_CHANGED        =  0x213;
const EventType WINDOW_DISPLAY_SCALE_CHANGED  =  0x214;
const EventType WINDOW_SAFE_AREA_CHANGED      =  0x215;
const EventType WINDOW_OCCLUDED               =  0x216;
const EventType WINDOW_ENTER_FULLSCREEN       =  0x217;
const EventType WINDOW_LEAVE_FULLSCREEN       =  0x218;
const EventType WINDOW_DESTROYED              =  0x219;
const EventType WINDOW_HDR_STATE_CHANGED      =  0x21a;
const EventType WINDOW_FIRST                  =  0x202;
const EventType WINDOW_LAST                   =  0x21a;
const EventType KEY_DOWN                      =  0x300;
const EventType KEY_UP                        =  0x301;
const EventType TEXT_EDITING                  =  0x302;
const EventType TEXT_INPUT                    =  0x303;
const EventType KEYMAP_CHANGED                =  0x304;
const EventType KEYBOARD_ADDED                =  0x305;
const EventType KEYBOARD_REMOVED              =  0x306;
const EventType TEXT_EDITING_CANDIDATES       =  0x307;
const EventType MOUSE_MOTION                  =  0x400;
const EventType MOUSE_BUTTON_DOWN             =  0x401;
const EventType MOUSE_BUTTON_UP               =  0x402;
const EventType MOUSE_WHEEL                   =  0x403;
const EventType MOUSE_ADDED                   =  0x404;
const EventType MOUSE_REMOVED                 =  0x405;
const EventType JOYSTICK_AXIS_MOTION          =  0x600;
const EventType JOYSTICK_BALL_MOTION          =  0x601;
const EventType JOYSTICK_HAT_MOTION           =  0x602;
const EventType JOYSTICK_BUTTON_DOWN          =  0x603;
const EventType JOYSTICK_BUTTON_UP            =  0x604;
const EventType JOYSTICK_ADDED                =  0x605;
const EventType JOYSTICK_REMOVED              =  0x606;
const EventType JOYSTICK_BATTERY_UPDATED      =  0x607;
const EventType JOYSTICK_UPDATE_COMPLETE      =  0x608;
const EventType GAMEPAD_AXIS_MOTION           =  0x650;
const EventType GAMEPAD_BUTTON_DOWN           =  0x651;
const EventType GAMEPAD_BUTTON_UP             =  0x652;
const EventType GAMEPAD_ADDED                 =  0x653;
const EventType GAMEPAD_REMOVED               =  0x654;
const EventType GAMEPAD_REMAPPED              =  0x655;
const EventType GAMEPAD_TOUCHPAD_DOWN         =  0x656;
const EventType GAMEPAD_TOUCHPAD_MOTION       =  0x657;
const EventType GAMEPAD_TOUCHPAD_UP           =  0x658;
const EventType GAMEPAD_SENSOR_UPDATE         =  0x659;
const EventType GAMEPAD_UPDATE_COMPLETE       =  0x65a;
const EventType GAMEPAD_STEAM_HANDLE_UPDATED  =  0x65b;
const EventType FINGER_DOWN                   =  0x700;
const EventType FINGER_UP                     =  0x701;
const EventType FINGER_MOTION                 =  0x702;
const EventType CLIPBOARD_UPDATE              =  0x900;
const EventType DROP_FILE                     =  0x1000;
const EventType DROP_TEXT                     =  0x1001;
const EventType DROP_BEGIN                    =  0x1002;
const EventType DROP_COMPLETE                 =  0x1003;
const EventType DROP_POSITION                 =  0x1004;
const EventType AUDIO_DEVICE_ADDED            =  0x1100;
const EventType AUDIO_DEVICE_REMOVED          =  0x1101;
const EventType AUDIO_DEVICE_FORMAT_CHANGED   =  0x1102;
const EventType SENSOR_UPDATE                 =  0x1200;
const EventType PEN_PROXIMITY_IN              =  0x1300;
const EventType PEN_PROXIMITY_OUT             =  0x1301;
const EventType PEN_DOWN                      =  0x1302;
const EventType PEN_UP                        =  0x1303;
const EventType PEN_BUTTON_DOWN               =  0x1304;
const EventType PEN_BUTTON_UP                 =  0x1305;
const EventType PEN_MOTION                    =  0x1306;
const EventType PEN_AXIS                      =  0x1307;
const EventType CAMERA_DEVICE_ADDED           =  0x1400;
const EventType CAMERA_DEVICE_REMOVED         =  0x1401;
const EventType CAMERA_DEVICE_APPROVED        =  0x1402;
const EventType CAMERA_DEVICE_DENIED          =  0x1403;
const EventType RENDER_TARGETS_RESET          =  0x2000;
const EventType RENDER_DEVICE_RESET           =  0x2001;
const EventType POLL_SENTINEL                 =  0x7f00;
const EventType USER                          =  0x8000;
const EventType LAST                          =  0xffff;
const EventType ENUM_PADDING                  =  0x7fffffff;

module sdl3;

distinct Folder = uint;
distinct GlobFlags = uint;
distinct PathType = uint;

def EnumerateDirectoryCallback = fn int(void* userdata, ZString dirname, ZString fname);

struct PathInfo
{
    PathType type;
    ulong size;
    Time create_time;
    Time modify_time;
    Time access_time;
}

fn char** _glob_directory(ZString path, ZString pattern, GlobFlags flags, int* count) @extern("SDL_GlobDirectory") @local;

macro ZString[] glob_directory(ZString path, ZString pattern = null, GlobFlags flags = glob_flags::CASEINSENSITIVE)
{
    int count;
    char** _files = _glob_directory(path, pattern, flags, &count);

    ZString[] files = mem::new_array(ZString, count);
    for (int i = 0; i < count; ++i) files[i] = (ZString)_files[i];
    return files;
}

fn int copy_file(ZString oldpath, ZString newpath) @extern("SDL_CopyFile");
fn int create_directory(ZString path) @extern("SDL_CreateDirectory");
fn int enumerate_directory(ZString path, EnumerateDirectoryCallback callback, void* userdata) @extern("SDL_EnumerateDirectory");
fn ZString get_base_path() @extern("SDL_GetBasePath");
fn int get_path_info(ZString path, PathInfo* info) @extern("SDL_GetPathInfo");
fn ZString get_pref_path(ZString org, ZString app) @extern("SDL_GetPrefPath");
fn ZString get_user_folder(Folder folder) @extern("SDL_GetUserFolder");
fn int remove_path(ZString path) @extern("SDL_RemovePath");
fn int rename_path(ZString oldpath, ZString newpath) @extern("SDL_RenamePath");

module sdl3::folder;

const Folder HOME         =  0;
const Folder DESKTOP      =  1;
const Folder DOCUMENTS    =  2;
const Folder DOWNLOADS    =  3;
const Folder MUSIC        =  4;
const Folder PICTURES     =  5;
const Folder PUBLICSHARE  =  6;
const Folder SAVEDGAMES   =  7;
const Folder SCREENSHOTS  =  8;
const Folder TEMPLATES    =  9;
const Folder VIDEOS       =  10;
const Folder TOTAL        =  11;

module sdl3::glob_flags;

const GlobFlags NONE             =  0x0;
const GlobFlags CASEINSENSITIVE  =  (1u << 0);

module sdl3::path_type;

const PathType NONE       =  0;
const PathType FILE       =  1;
const PathType DIRECTORY  =  2;
const PathType OTHER      =  3;

module sdl3;

distinct Gamepad = void*;
distinct GamepadAxis = int;
distinct GamepadBindingType = uint;
distinct GamepadButton = int;
distinct GamepadButtonLabel = uint;
distinct GamepadType = uint;


struct GamepadBinding
{
    GamepadBindingType input_type;
    union input
    {
        int button;

        struct axis
        {
            int axis;
            int axis_min;
            int axis_max;
        }

        struct hat
        {
            int hat;
            int hat_mask;
        }

    }

    GamepadBindingType output_type;
    union output
    {
        GamepadButton button;

        struct axis
        {
            GamepadAxis axis;
            int axis_min;
            int axis_max;
        }

    }
}

fn int add_gamepad_mapping(ZString mapping) @extern("SDL_AddGamepadMapping");
fn int add_gamepad_mappings_from_file(ZString file) @extern("SDL_AddGamepadMappingsFromFile");
fn int add_gamepad_mappings_from_io(IOStream* src, bool closeio) @extern("SDL_AddGamepadMappingsFromIO");
fn void close_gamepad(Gamepad* gamepad) @extern("SDL_CloseGamepad");
fn bool gamepad_connected(Gamepad* gamepad) @extern("SDL_GamepadConnected");
fn bool gamepad_events_enabled() @extern("SDL_GamepadEventsEnabled");
fn bool gamepad_has_axis(Gamepad* gamepad, GamepadAxis axis) @extern("SDL_GamepadHasAxis");
fn bool gamepad_has_button(Gamepad* gamepad, GamepadButton button) @extern("SDL_GamepadHasButton");
fn bool gamepad_has_sensor(Gamepad* gamepad, SensorType type) @extern("SDL_GamepadHasSensor");
fn bool gamepad_sensor_enabled(Gamepad* gamepad, SensorType type) @extern("SDL_GamepadSensorEnabled");
fn ZString get_gamepad_apple_sf_symbols_name_for_axis(Gamepad* gamepad, GamepadAxis axis) @extern("SDL_GetGamepadAppleSFSymbolsNameForAxis");
fn ZString get_gamepad_apple_sf_symbols_name_for_button(Gamepad* gamepad, GamepadButton button) @extern("SDL_GetGamepadAppleSFSymbolsNameForButton");
fn short get_gamepad_axis(Gamepad* gamepad, GamepadAxis axis) @extern("SDL_GetGamepadAxis");
fn GamepadAxis get_gamepad_axis_from_string(ZString str) @extern("SDL_GetGamepadAxisFromString");

fn GamepadBinding** _get_gamepad_bindings(Gamepad* gamepad, int* count) @extern("SDL_GetGamepadBindings") @local;

macro GamepadBinding[] get_gamepad_bindings(Gamepad* gamepad)
{
    int count;
    GamepadBinding** _bindings = _get_gamepad_bindings(gamepad, &count);

    GamepadBinding[] bindings = mem::new_array(GamepadBinding, count);
    for (int i = 0; i < count; ++i) bindings[i] = (GamepadBinding)*_bindings[i];
    return bindings;
}

fn char get_gamepad_button(Gamepad* gamepad, GamepadButton button) @extern("SDL_GetGamepadButton");
fn GamepadButton get_gamepad_button_from_string(ZString str) @extern("SDL_GetGamepadButtonFromString");
fn GamepadButtonLabel get_gamepad_button_label(Gamepad* gamepad, GamepadButton button) @extern("SDL_GetGamepadButtonLabel");
fn GamepadButtonLabel get_gamepad_button_label_for_type(GamepadType type, GamepadButton button) @extern("SDL_GetGamepadButtonLabelForType");
fn JoystickConnectionState get_gamepad_connection_state(Gamepad* gamepad) @extern("SDL_GetGamepadConnectionState");
fn ushort get_gamepad_firmware_version(Gamepad* gamepad) @extern("SDL_GetGamepadFirmwareVersion");
fn Gamepad* get_gamepad_from_id(JoystickID instance_id) @extern("SDL_GetGamepadFromID");
fn Gamepad* get_gamepad_from_player_index(int player_index) @extern("SDL_GetGamepadFromPlayerIndex");
fn Guid get_gamepad_guid_for_id(JoystickID instance_id) @extern("SDL_GetGamepadGUIDForID");
fn JoystickID get_gamepad_id(Gamepad* gamepad) @extern("SDL_GetGamepadID");
fn Joystick* get_gamepad_joystick(Gamepad* gamepad) @extern("SDL_GetGamepadJoystick");
fn ZString get_gamepad_mapping(Gamepad* gamepad) @extern("SDL_GetGamepadMapping");
fn ZString get_gamepad_mapping_for_guid(Guid guid) @extern("SDL_GetGamepadMappingForGUID");
fn ZString get_gamepad_mapping_for_id(JoystickID instance_id) @extern("SDL_GetGamepadMappingForID");

fn char** _get_gamepad_mappings(int* count) @extern("SDL_GetGamepadMappings") @local;

macro ZString[] get_gamepad_mappings()
{
    int count;
    char** _mappings = _get_gamepad_mappings(&count);

    ZString[] mappings = mem::new_array(ZString, count);
    for (int i = 0; i < count; ++i) mappings[i] = (ZString)_mappings[i];
    return mappings;
}

fn ZString get_gamepad_name(Gamepad* gamepad) @extern("SDL_GetGamepadName");
fn ZString get_gamepad_name_for_id(JoystickID instance_id) @extern("SDL_GetGamepadNameForID");
fn ZString get_gamepad_path(Gamepad* gamepad) @extern("SDL_GetGamepadPath");
fn ZString get_gamepad_path_for_id(JoystickID instance_id) @extern("SDL_GetGamepadPathForID");
fn int get_gamepad_player_index(Gamepad* gamepad) @extern("SDL_GetGamepadPlayerIndex");
fn int get_gamepad_player_index_for_id(JoystickID instance_id) @extern("SDL_GetGamepadPlayerIndexForID");
fn PowerState get_gamepad_power_info(Gamepad* gamepad, int* percent) @extern("SDL_GetGamepadPowerInfo");
fn ushort get_gamepad_product(Gamepad* gamepad) @extern("SDL_GetGamepadProduct");
fn ushort get_gamepad_product_for_id(JoystickID instance_id) @extern("SDL_GetGamepadProductForID");
fn ushort get_gamepad_product_version(Gamepad* gamepad) @extern("SDL_GetGamepadProductVersion");
fn ushort get_gamepad_product_version_for_id(JoystickID instance_id) @extern("SDL_GetGamepadProductVersionForID");
fn PropertiesID get_gamepad_properties(Gamepad* gamepad) @extern("SDL_GetGamepadProperties");
fn JoystickID* get_gamepads(int* count) @extern("SDL_GetGamepads");
fn int get_gamepad_sensor_data(Gamepad* gamepad, SensorType type, float* data, int num_values) @extern("SDL_GetGamepadSensorData");
fn float get_gamepad_sensor_data_rate(Gamepad* gamepad, SensorType type) @extern("SDL_GetGamepadSensorDataRate");
fn ZString  get_gamepad_serial(Gamepad* gamepad) @extern("SDL_GetGamepadSerial");
fn ushort get_gamepad_steam_handle(Gamepad* gamepad) @extern("SDL_GetGamepadSteamHandle");
fn ZString get_gamepad_string_for_axis(GamepadAxis axis) @extern("SDL_GetGamepadStringForAxis");
fn ZString get_gamepad_string_for_button(GamepadButton button) @extern("SDL_GetGamepadStringForButton");
fn ZString get_gamepad_string_for_type(GamepadType type) @extern("SDL_GetGamepadStringForType");
fn int get_gamepad_touchpad_finger(Gamepad* gamepad, int touchpad, int finger, ZString state, float* x, float* y, float* pressure) @extern("SDL_GetGamepadTouchpadFinger");
fn GamepadType get_gamepad_type(Gamepad* gamepad) @extern("SDL_GetGamepadType");
fn GamepadType get_gamepad_type_for_id(JoystickID instance_id) @extern("SDL_GetGamepadTypeForID");
fn GamepadType get_gamepad_type_from_string(ZString str) @extern("SDL_GetGamepadTypeFromString");
fn ushort get_gamepad_vendor(Gamepad* gamepad) @extern("SDL_GetGamepadVendor");
fn ushort get_gamepad_vendor_for_id(JoystickID instance_id) @extern("SDL_GetGamepadVendorForID");
fn int get_num_gamepad_touchpad_fingers(Gamepad* gamepad, int touchpad) @extern("SDL_GetNumGamepadTouchpadFingers");
fn int get_num_gamepad_touchpads(Gamepad* gamepad) @extern("SDL_GetNumGamepadTouchpads");
fn GamepadType get_real_gamepad_type(Gamepad* gamepad) @extern("SDL_GetRealGamepadType");
fn GamepadType get_real_gamepad_type_for_id(JoystickID instance_id) @extern("SDL_GetRealGamepadTypeForID");
fn bool has_gamepad() @extern("SDL_HasGamepad");
fn bool is_gamepad(JoystickID instance_id) @extern("SDL_IsGamepad");
fn Gamepad* open_gamepad(JoystickID instance_id) @extern("SDL_OpenGamepad");
fn int reload_gamepad_mappings() @extern("SDL_ReloadGamepadMappings");
fn int rumble_gamepad(Gamepad* gamepad, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms) @extern("SDL_RumbleGamepad");
fn int rumble_gamepad_triggers(Gamepad* gamepad, ushort left_rumble, ushort right_rumble, uint duration_ms) @extern("SDL_RumbleGamepadTriggers");
fn int send_gamepad_effect(Gamepad* gamepad, void* data, int size) @extern("SDL_SendGamepadEffect");
fn void set_gamepad_events_enabled(bool enabled) @extern("SDL_SetGamepadEventsEnabled");
fn int set_gamepad_led(Gamepad* gamepad, char red, char green, char blue) @extern("SDL_SetGamepadLED");
fn int set_gamepad_mapping(JoystickID instance_id, ZString mapping) @extern("SDL_SetGamepadMapping");
fn int set_gamepad_player_index(Gamepad* gamepad, int player_index) @extern("SDL_SetGamepadPlayerIndex");
fn int set_gamepad_sensor_enabled(Gamepad* gamepad, SensorType type, bool enabled) @extern("SDL_SetGamepadSensorEnabled");
fn void update_gamepads() @extern("SDL_UpdateGamepads");

module sdl3::gamepad_axis;

const GamepadAxis INVALID        =  -1;
const GamepadAxis LEFTX          =   0;
const GamepadAxis LEFTY          =   1;
const GamepadAxis RIGHTX         =   2;
const GamepadAxis RIGHTY         =   3;
const GamepadAxis LEFT_TRIGGER   =   4;
const GamepadAxis RIGHT_TRIGGER  =   5;
const GamepadAxis MAX            =   6;

module sdl3::gamepad_binding_type;

const GamepadBindingType NONE    =  0;
const GamepadBindingType BUTTON  =  1;
const GamepadBindingType AXIS    =  2;
const GamepadBindingType HAT     =  3;

module sdl3::gamepad_button;

const GamepadButton INVALID         =  -1;
const GamepadButton SOUTH           =   0;
const GamepadButton EAST            =   1;
const GamepadButton WEST            =   2;
const GamepadButton NORTH           =   3;
const GamepadButton BACK            =   4;
const GamepadButton GUIDE           =   5;
const GamepadButton START           =   6;
const GamepadButton LEFT_STICK      =   7;
const GamepadButton RIGHT_STICK     =   8;
const GamepadButton LEFT_SHOULDER   =   9;
const GamepadButton RIGHT_SHOULDER  =  10;
const GamepadButton DPAD_UP         =  11;
const GamepadButton DPAD_DOWN       =  12;
const GamepadButton DPAD_LEFT       =  13;
const GamepadButton DPAD_RIGHT      =  14;
const GamepadButton MISC1           =  15;
const GamepadButton RIGHT_PADDLE1   =  16;
const GamepadButton LEFT_PADDLE1    =  17;
const GamepadButton RIGHT_PADDLE2   =  18;
const GamepadButton LEFT_PADDLE2    =  19;
const GamepadButton TOUCHPAD        =  20;
const GamepadButton MISC2           =  21;
const GamepadButton MISC3           =  22;
const GamepadButton MISC4           =  23;
const GamepadButton MISC5           =  24;
const GamepadButton MISC6           =  25;
const GamepadButton MAX             =  26;

module sdl3::gamepad_button_label;

const GamepadButtonLabel A         =  0x1;
const GamepadButtonLabel B         =  0x2;
const GamepadButtonLabel X         =  0x3;
const GamepadButtonLabel Y         =  0x4;
const GamepadButtonLabel CROSS     =  0x5;
const GamepadButtonLabel CIRCLE    =  0x6;
const GamepadButtonLabel SQUARE    =  0x7;
const GamepadButtonLabel TRIANGLE  =  0x8;

module sdl3::gamepad_type;

const GamepadType UNKNOWN                       =  0x0;
const GamepadType STANDARD                      =  0x1;
const GamepadType XBOX360                       =  0x2;
const GamepadType XBOXONE                       =  0x3;
const GamepadType PS3                           =  0x4;
const GamepadType PS4                           =  0x5;
const GamepadType PS5                           =  0x6;
const GamepadType NINTENDO_SWITCH_PRO           =  0x7;
const GamepadType NINTENDO_SWITCH_JOYCON_LEFT   =  0x8;
const GamepadType NINTENDO_SWITCH_JOYCON_RIGHT  =  0x9;
const GamepadType NINTENDO_SWITCH_JOYCON_PAIR   =  0xa;
const GamepadType MAX                           =  0xb;

module sdl3;

distinct Guid = void*;

fn void guid_to_string(Guid* guid, ZString pszGUID, int cbGUID) @extern("SDL_GUIDToString");
fn Guid* string_to_guid(ZString pchGUID) @extern("SDL_StringToGUID");

module sdl3;

const uint HAPTIC_CONSTANT       =  (1u<<0);
const uint HAPTIC_SINE           =  (1u<<1);
const uint HAPTIC_SQUARE         =  (1u<<2);
const uint HAPTIC_TRIANGLE       =  (1u<<3);
const uint HAPTIC_SAWTOOTHUP     =  (1u<<4);
const uint HAPTIC_SAWTOOTHDOWN   =  (1u<<5);
const uint HAPTIC_RAMP           =  (1u<<6);
const uint HAPTIC_SPRING         =  (1u<<7);
const uint HAPTIC_DAMPER         =  (1u<<8);
const uint HAPTIC_INERTIA        =  (1u<<9);
const uint HAPTIC_FRICTION       =  (1u<<10);
const uint HAPTIC_LEFTRIGHT      =  (1u<<11);
const uint HAPTIC_RESERVED1      =  (1u<<12);
const uint HAPTIC_RESERVED2      =  (1u<<13);
const uint HAPTIC_RESERVED3      =  (1u<<14);
const uint HAPTIC_CUSTOM         =  (1u<<15);
const uint HAPTIC_GAIN           =  (1u<<16);
const uint HAPTIC_AUTOCENTER     =  (1u<<17);
const uint HAPTIC_STATUS         =  (1u<<18);
const uint HAPTIC_PAUSE          =  (1u<<19);
const uint HAPTIC_POLAR          =  0;
const uint HAPTIC_CARTESIAN      =  1;
const uint HAPTIC_SPHERICAL      =  2;
const uint HAPTIC_STEERING_AXIS  =  3;
const uint HAPTIC_INFINITY       =  4294967295U;

distinct HapticID = uint;
distinct Haptic = void*;

struct HapticCondition
{
    ushort type;
    HapticDirection direction;
    uint length;
    ushort delay;

    ushort button;
    ushort interval;

    ushort[3] right_sat;
    ushort[3] left_sat;
    short[3] right_coeff;
    short[3] left_coeff;
    ushort[3] deadband;
    short[3]  center;
}

struct HapticConstant
{
    ushort type;
    HapticDirection direction;

    uint length;
    ushort delay;

    ushort button;
    ushort interval;

    short level;

    ushort attack_length;
    ushort attack_level;
    ushort fade_length;
    ushort fade_level;
}

struct HapticCustom
{

    ushort type;
    HapticDirection direction;

    uint length;
    ushort delay;

    ushort button;
    ushort interval;

    char channels;
    ushort period;
    ushort samples;
    ushort* data;

    ushort attack_length;
    ushort attack_level;
    ushort fade_length;
    ushort fade_level;
}

struct HapticDirection
{
    uint  type;
    int[3] dir;
}

union HapticEffect
{

    ushort type;
    HapticConstant constant;
    HapticPeriodic periodic;
    HapticCondition condition;
    HapticRamp ramp;
    HapticLeftRight leftright;
    HapticCustom custom;
}

struct HapticLeftRight
{
    ushort type;

    uint length;

    ushort large_magnitude;
    ushort small_magnitude;
}

struct HapticPeriodic
{
    ushort type;

    HapticDirection direction;

    uint length;
    ushort delay;

    ushort button;
    ushort interval;

    ushort period;
    short  magnitude;
    short  offset;
    ushort phase;

    ushort attack_length;
    ushort attack_level;
    ushort fade_length;
    ushort fade_level;
}

struct HapticRamp
{
    ushort type;
    HapticDirection direction;

    uint length;
    ushort delay;

    ushort button;
    ushort interval;

    short start;
    short end;

    ushort attack_length;
    ushort attack_level;
    ushort fade_length;
    ushort fade_level;
}

fn void close_haptic(Haptic* haptic) @extern("SDL_CloseHaptic");
fn int create_haptic_effect(Haptic* haptic, HapticEffect* effect) @extern("SDL_CreateHapticEffect");
fn void destroy_haptic_effect(Haptic* haptic, int effect) @extern("SDL_DestroyHapticEffect");
fn int get_haptic_effect_status(Haptic* haptic, int effect) @extern("SDL_GetHapticEffectStatus");
fn uint get_haptic_features(Haptic* haptic) @extern("SDL_GetHapticFeatures");
fn Haptic* get_haptic_from_id(HapticID instance_id) @extern("SDL_GetHapticFromID");
fn HapticID get_haptic_id(Haptic* haptic) @extern("SDL_GetHapticID");
fn ZString get_haptic_name(Haptic* haptic) @extern("SDL_GetHapticName");
fn ZString get_haptic_name_for_id(HapticID instance_id) @extern("SDL_GetHapticNameForID");
fn HapticID* get_haptics(int* count) @extern("SDL_GetHaptics");
fn int get_max_haptic_effects(Haptic* haptic) @extern("SDL_GetMaxHapticEffects");
fn int get_max_haptic_effects_playing(Haptic* haptic) @extern("SDL_GetMaxHapticEffectsPlaying");
fn int get_num_haptic_axes(Haptic* haptic) @extern("SDL_GetNumHapticAxes");
fn bool haptic_effect_supported(Haptic* haptic, HapticEffect* effect) @extern("SDL_HapticEffectSupported");
fn bool haptic_rumble_supported(Haptic* haptic) @extern("SDL_HapticRumbleSupported");
fn int init_haptic_rumble(Haptic* haptic) @extern("SDL_InitHapticRumble");
fn bool is_joystick_haptic(Joystick* joystick) @extern("SDL_IsJoystickHaptic");
fn bool is_mouse_haptic() @extern("SDL_IsMouseHaptic");
fn Haptic* open_haptic(HapticID instance_id) @extern("SDL_OpenHaptic");
fn Haptic* open_haptic_from_joystick(Joystick* joystick) @extern("SDL_OpenHapticFromJoystick");
fn Haptic* open_haptic_from_mouse() @extern("SDL_OpenHapticFromMouse");
fn int pause_haptic(Haptic* haptic) @extern("SDL_PauseHaptic");
fn int play_haptic_rumble(Haptic* haptic, float strength, uint length) @extern("SDL_PlayHapticRumble");
fn int resume_haptic(Haptic* haptic) @extern("SDL_ResumeHaptic");
fn int run_haptic_effect(Haptic* haptic, int effect, uint iterations) @extern("SDL_RunHapticEffect");
fn int set_haptic_autocenter(Haptic* haptic, int autocenter) @extern("SDL_SetHapticAutocenter");
fn int set_haptic_gain(Haptic* haptic, int gain) @extern("SDL_SetHapticGain");
fn int stop_haptic_effect(Haptic* haptic, int effect) @extern("SDL_StopHapticEffect");
fn int stop_haptic_effects(Haptic* haptic) @extern("SDL_StopHapticEffects");
fn int stop_haptic_rumble(Haptic* haptic) @extern("SDL_StopHapticRumble");
fn int update_haptic_effect(Haptic* haptic, int effect, HapticEffect* data) @extern("SDL_UpdateHapticEffect");

module sdl3;

distinct HIDevice = void*;
distinct HIDBusType = uint;

struct HIDeviceInfo
{
    ZString path;
    ushort vendor_id;
    ushort product_id;
    ZString serial_number;
    ushort release_number;
    ZString manufacturer_string;
    ZString product_string;
    ushort usage_page;
    ushort usage;
    int interface_number;
    int interface_class;
    int interface_subclass;
    int interface_protocol;

    HIDBusType    bus_type;
    HIDeviceInfo* next;
}

fn void hid_ble_scan(bool active) @extern("SDL_hid_ble_scan");
fn void hid_close(HIDevice* dev) @extern("SDL_hid_close");
fn uint hid_device_change_count() @extern("SDL_hid_device_change_count");
fn HIDeviceInfo* hid_enumerate(ushort vendor_id, ushort product_id) @extern("SDL_hid_enumerate");
fn int hid_exit() @extern("SDL_hid_exit");
fn void hid_free_enumeration(HIDeviceInfo* devs) @extern("SDL_hid_free_enumeration");
fn HIDeviceInfo* hid_get_device_info(HIDevice* dev) @extern("SDL_hid_get_device_info");
fn int hid_get_feature_report(HIDevice* dev, ZString data, usz length) @extern("SDL_hid_get_feature_report");
fn int hid_get_indexed_string(HIDevice* dev, int string_index, ZString string, usz maxlen) @extern("SDL_hid_get_indexed_string");
fn int hid_get_input_report(HIDevice* dev, ZString data, usz length) @extern("SDL_hid_get_input_report");
fn int hid_get_manufacturer_string(HIDevice* dev, ZString string, usz maxlen) @extern("SDL_hid_get_manufacturer_string");
fn int hid_get_product_string(HIDevice* dev, ZString string, usz maxlen) @extern("SDL_hid_get_product_string");
fn int hid_get_report_descriptor(HIDevice* dev, ZString buf, usz buf_size) @extern("SDL_hid_get_report_descriptor");
fn int hid_get_serial_number_string(HIDevice* dev, ZString string, usz maxlen) @extern("SDL_hid_get_serial_number_string");
fn int hid_init() @extern("SDL_hid_init");
fn HIDevice* hid_open(ushort vendor_id, ushort product_id, ZString serial_number) @extern("SDL_hid_open");
fn HIDevice* hid_open_path(char) @extern("SDL_hid_open_path");
fn int hid_read(HIDevice* dev, ZString data, usz length) @extern("SDL_hid_read");
fn int hid_read_timeout(HIDevice* dev, ZString data, usz length, int milliseconds) @extern("SDL_hid_read_timeout");
fn int hid_send_feature_report(HIDevice, ZString data, usz length) @extern("SDL_hid_send_feature_report");
fn int hid_set_nonblocking(HIDevice* dev, int nonblock) @extern("SDL_hid_set_nonblocking");
fn int hid_write(HIDevice* dev, ZString data, usz length) @extern("SDL_hid_write");

module sdl3::hid_bus_type;

const HIDBusType UNKNOWN    =  0x00;
const HIDBusType USB        =  0x01;
const HIDBusType BLUETOOTH  =  0x02;
const HIDBusType I2C        =  0x03;
const HIDBusType SPI        =  0x04;

module sdl3;

distinct Hint = inline char*;
distinct HintPriority = int;


def HintCallback = fn void(void* userdata, ZString name, ZString oldValue, ZString newValue);

fn int add_hint_callback(ZString name, HintCallback callback, void* userdata) @extern("SDL_AddHintCallback");
fn void del_hint_callback(ZString name, HintCallback callback, void* userdata) @extern("SDL_DelHintCallback");
fn ZString get_hint(ZString name) @extern("SDL_GetHint");
fn int reset_hint(ZString name) @extern("SDL_ResetHint");
fn void reset_hints() @extern("SDL_ResetHints");
fn int set_hint(ZString name, ZString value) @extern("SDL_SetHint");
fn int set_hint_with_priority(ZString name, ZString value, HintPriority priority) @extern("SDL_SetHintWithPriority");
fn bool get_hint_boolean(ZString name, bool default_value) @extern("SDL_GetHintBoolean");

module sdl3::hint_priority;

const HintPriority DEFAULT  = 0;
const HintPriority NORMAL   = 1;
const HintPriority OVERRIDE = 2;

module sdl3::hint;

const Hint ALLOW_ALT_TAB_WHILE_GRABBED              = "SDL_ALLOW_ALT_TAB_WHILE_GRABBED";
const Hint ANDROID_ALLOW_RECREATE_ACTIVITY          = "SDL_ANDROID_ALLOW_RECREATE_ACTIVITY";
const Hint ANDROID_BLOCK_ON_PAUSE                   = "SDL_ANDROID_BLOCK_ON_PAUSE";
const Hint ANDROID_TRAP_BACK_BUTTON                 = "SDL_ANDROID_TRAP_BACK_BUTTON";
const Hint APP_ID                                   = "SDL_APP_ID";
const Hint APP_NAME                                 = "SDL_APP_NAME";
const Hint APPLE_TV_CONTROLLER_UI_EVENTS            = "SDL_APPLE_TV_CONTROLLER_UI_EVENTS";
const Hint APPLE_TV_REMOTE_ALLOW_ROTATION           = "SDL_APPLE_TV_REMOTE_ALLOW_ROTATION";
const Hint AUDIO_ALSA_DEFAULT_DEVICE                = "SDL_AUDIO_ALSA_DEFAULT_DEVICE";
const Hint AUDIO_CATEGORY                           = "SDL_AUDIO_CATEGORY";
const Hint AUDIO_CHANNELS                           = "SDL_AUDIO_CHANNELS";
const Hint AUDIO_DEVICE_APP_ICON_NAME               = "SDL_AUDIO_DEVICE_APP_ICON_NAME";
const Hint AUDIO_DEVICE_SAMPLE_FRAMES               = "SDL_AUDIO_DEVICE_SAMPLE_FRAMES";
const Hint AUDIO_DEVICE_STREAM_NAME                 = "SDL_AUDIO_DEVICE_STREAM_NAME";
const Hint AUDIO_DEVICE_STREAM_ROLE                 = "SDL_AUDIO_DEVICE_STREAM_ROLE";
const Hint AUDIO_DISK_INPUT_FILE                    = "SDL_AUDIO_DISK_INPUT_FILE";
const Hint AUDIO_DISK_OUTPUT_FILE                   = "SDL_AUDIO_DISK_OUTPUT_FILE";
const Hint AUDIO_DISK_TIMESCALE                     = "SDL_AUDIO_DISK_TIMESCALE";
const Hint AUDIO_DRIVER                             = "SDL_AUDIO_DRIVER";
const Hint AUDIO_DUMMY_TIMESCALE                    = "SDL_AUDIO_DUMMY_TIMESCALE";
const Hint AUDIO_FORMAT                             = "SDL_AUDIO_FORMAT";
const Hint AUDIO_FREQUENCY                          = "SDL_AUDIO_FREQUENCY";
const Hint AUDIO_INCLUDE_MONITORS                   = "SDL_AUDIO_INCLUDE_MONITORS";
const Hint AUTO_UPDATE_JOYSTICKS                    = "SDL_AUTO_UPDATE_JOYSTICKS";
const Hint AUTO_UPDATE_SENSORS                      = "SDL_AUTO_UPDATE_SENSORS";
const Hint BMP_SAVE_LEGACY_FORMAT                   = "SDL_BMP_SAVE_LEGACY_FORMAT";
const Hint CAMERA_DRIVER                            = "SDL_CAMERA_DRIVER";
const Hint CPU_FEATURE_MASK                         = "SDL_CPU_FEATURE_MASK";
const Hint JOYSTICK_DIRECTINPUT                     = "SDL_JOYSTICK_DIRECTINPUT";
const Hint FILE_DIALOG_DRIVER                       = "SDL_FILE_DIALOG_DRIVER";
const Hint DISPLAY_USABLE_BOUNDS                    = "SDL_DISPLAY_USABLE_BOUNDS";
const Hint EMSCRIPTEN_ASYNCIFY                      = "SDL_EMSCRIPTEN_ASYNCIFY";
const Hint EMSCRIPTEN_CANVAS_SELECTOR               = "SDL_EMSCRIPTEN_CANVAS_SELECTOR";
const Hint EMSCRIPTEN_KEYBOARD_ELEMENT              = "SDL_EMSCRIPTEN_KEYBOARD_ELEMENT";
const Hint ENABLE_SCREEN_KEYBOARD                   = "SDL_ENABLE_SCREEN_KEYBOARD";
const Hint EVDEV_DEVICES                            = "SDL_EVDEV_DEVICES";
const Hint EVENT_LOGGING                            = "SDL_EVENT_LOGGING";
const Hint FORCE_RAISEWINDOW                        = "SDL_FORCE_RAISEWINDOW";
const Hint FRAMEBUFFER_ACCELERATION                 = "SDL_FRAMEBUFFER_ACCELERATION";
const Hint GAMECONTROLLERCONFIG                     = "SDL_GAMECONTROLLERCONFIG";
const Hint GAMECONTROLLERCONFIG_FILE                = "SDL_GAMECONTROLLERCONFIG_FILE";
const Hint GAMECONTROLLERTYPE                       = "SDL_GAMECONTROLLERTYPE";
const Hint GAMECONTROLLER_IGNORE_DEVICES            = "SDL_GAMECONTROLLER_IGNORE_DEVICES";
const Hint GAMECONTROLLER_IGNORE_DEVICES_EXCEPT     = "SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT";
const Hint GAMECONTROLLER_SENSOR_FUSION             = "SDL_GAMECONTROLLER_SENSOR_FUSION";
const Hint GDK_TEXTINPUT_DEFAULT_TEXT               = "SDL_GDK_TEXTINPUT_DEFAULT_TEXT";
const Hint GDK_TEXTINPUT_DESCRIPTION                = "SDL_GDK_TEXTINPUT_DESCRIPTION";
const Hint GDK_TEXTINPUT_MAX_LENGTH                 = "SDL_GDK_TEXTINPUT_MAX_LENGTH";
const Hint GDK_TEXTINPUT_SCOPE                      = "SDL_GDK_TEXTINPUT_SCOPE";
const Hint GDK_TEXTINPUT_TITLE                      = "SDL_GDK_TEXTINPUT_TITLE";
const Hint HIDAPI_LIBUSB                            = "SDL_HIDAPI_LIBUSB";
const Hint HIDAPI_LIBUSB_WHITELIST                  = "SDL_HIDAPI_LIBUSB_WHITELIST";
const Hint HIDAPI_UDEV                              = "SDL_HIDAPI_UDEV";
const Hint HIDAPI_ENUMERATE_ONLY_CONTROLLERS        = "SDL_HIDAPI_ENUMERATE_ONLY_CONTROLLERS";
const Hint HIDAPI_IGNORE_DEVICES                    = "SDL_HIDAPI_IGNORE_DEVICES";
const Hint IME_IMPLEMENTED_UI                       = "SDL_IME_IMPLEMENTED_UI";
const Hint IOS_HIDE_HOME_INDICATOR                  = "SDL_IOS_HIDE_HOME_INDICATOR";
const Hint JOYSTICK_ALLOW_BACKGROUND_EVENTS         = "SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS";
const Hint JOYSTICK_ARCADESTICK_DEVICES             = "SDL_JOYSTICK_ARCADESTICK_DEVICES";
const Hint JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED    = "SDL_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED";
const Hint JOYSTICK_BLACKLIST_DEVICES               = "SDL_JOYSTICK_BLACKLIST_DEVICES";
const Hint JOYSTICK_BLACKLIST_DEVICES_EXCLUDED      = "SDL_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED";
const Hint JOYSTICK_DEVICE                          = "SDL_JOYSTICK_DEVICE";
const Hint JOYSTICK_FLIGHTSTICK_DEVICES             = "SDL_JOYSTICK_FLIGHTSTICK_DEVICES";
const Hint JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED    = "SDL_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED";
const Hint JOYSTICK_GAMEINPUT                       = "SDL_JOYSTICK_GAMEINPUT";
const Hint JOYSTICK_GAMECUBE_DEVICES                = "SDL_JOYSTICK_GAMECUBE_DEVICES";
const Hint JOYSTICK_GAMECUBE_DEVICES_EXCLUDED       = "SDL_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED";
const Hint JOYSTICK_HIDAPI                          = "SDL_JOYSTICK_HIDAPI";
const Hint JOYSTICK_HIDAPI_COMBINE_JOY_CONS         = "SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS";
const Hint JOYSTICK_HIDAPI_GAMECUBE                 = "SDL_JOYSTICK_HIDAPI_GAMECUBE";
const Hint JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE    = "SDL_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE";
const Hint JOYSTICK_HIDAPI_JOY_CONS                 = "SDL_JOYSTICK_HIDAPI_JOY_CONS";
const Hint JOYSTICK_HIDAPI_JOYCON_HOME_LED          = "SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED";
const Hint JOYSTICK_HIDAPI_LUNA                     = "SDL_JOYSTICK_HIDAPI_LUNA";
const Hint JOYSTICK_HIDAPI_NINTENDO_CLASSIC         = "SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC";
const Hint JOYSTICK_HIDAPI_PS3                      = "SDL_JOYSTICK_HIDAPI_PS3";
const Hint JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER       = "SDL_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER";
const Hint JOYSTICK_HIDAPI_PS4                      = "SDL_JOYSTICK_HIDAPI_PS4";
const Hint JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL      = "SDL_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL";
const Hint JOYSTICK_HIDAPI_PS4_RUMBLE               = "SDL_JOYSTICK_HIDAPI_PS4_RUMBLE";
const Hint JOYSTICK_HIDAPI_PS5                      = "SDL_JOYSTICK_HIDAPI_PS5";
const Hint JOYSTICK_HIDAPI_PS5_PLAYER_LED           = "SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED";
const Hint JOYSTICK_HIDAPI_PS5_RUMBLE               = "SDL_JOYSTICK_HIDAPI_PS5_RUMBLE";
const Hint JOYSTICK_HIDAPI_SHIELD                   = "SDL_JOYSTICK_HIDAPI_SHIELD";
const Hint JOYSTICK_HIDAPI_STADIA                   = "SDL_JOYSTICK_HIDAPI_STADIA";
const Hint JOYSTICK_HIDAPI_STEAM                    = "SDL_JOYSTICK_HIDAPI_STEAM";
const Hint JOYSTICK_HIDAPI_STEAMDECK                = "SDL_JOYSTICK_HIDAPI_STEAMDECK";
const Hint JOYSTICK_HIDAPI_SWITCH                   = "SDL_JOYSTICK_HIDAPI_SWITCH";
const Hint JOYSTICK_HIDAPI_SWITCH_HOME_LED          = "SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED";
const Hint JOYSTICK_HIDAPI_SWITCH_PLAYER_LED        = "SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED";
const Hint JOYSTICK_HIDAPI_VERTICAL_JOY_CONS        = "SDL_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS";
const Hint JOYSTICK_HIDAPI_WII                      = "SDL_JOYSTICK_HIDAPI_WII";
const Hint JOYSTICK_HIDAPI_WII_PLAYER_LED           = "SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED";
const Hint JOYSTICK_HIDAPI_XBOX                     = "SDL_JOYSTICK_HIDAPI_XBOX";
const Hint JOYSTICK_HIDAPI_XBOX_360                 = "SDL_JOYSTICK_HIDAPI_XBOX_360";
const Hint JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED      = "SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED";
const Hint JOYSTICK_HIDAPI_XBOX_360_WIRELESS        = "SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS";
const Hint JOYSTICK_HIDAPI_XBOX_ONE                 = "SDL_JOYSTICK_HIDAPI_XBOX_ONE";
const Hint JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED        = "SDL_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED";
const Hint JOYSTICK_IOKIT                           = "SDL_JOYSTICK_IOKIT";
const Hint JOYSTICK_LINUX_CLASSIC                   = "SDL_JOYSTICK_LINUX_CLASSIC";
const Hint JOYSTICK_LINUX_DEADZONES                 = "SDL_JOYSTICK_LINUX_DEADZONES";
const Hint JOYSTICK_LINUX_DIGITAL_HATS              = "SDL_JOYSTICK_LINUX_DIGITAL_HATS";
const Hint JOYSTICK_LINUX_HAT_DEADZONES             = "SDL_JOYSTICK_LINUX_HAT_DEADZONES";
const Hint JOYSTICK_MFI                             = "SDL_JOYSTICK_MFI";
const Hint JOYSTICK_RAWINPUT                        = "SDL_JOYSTICK_RAWINPUT";
const Hint JOYSTICK_RAWINPUT_CORRELATE_XINPUT       = "SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT";
const Hint JOYSTICK_ROG_CHAKRAM                     = "SDL_JOYSTICK_ROG_CHAKRAM";
const Hint JOYSTICK_THREAD                          = "SDL_JOYSTICK_THREAD";
const Hint JOYSTICK_THROTTLE_DEVICES                = "SDL_JOYSTICK_THROTTLE_DEVICES";
const Hint JOYSTICK_THROTTLE_DEVICES_EXCLUDED       = "SDL_JOYSTICK_THROTTLE_DEVICES_EXCLUDED";
const Hint JOYSTICK_WGI                             = "SDL_JOYSTICK_WGI";
const Hint JOYSTICK_WHEEL_DEVICES                   = "SDL_JOYSTICK_WHEEL_DEVICES";
const Hint JOYSTICK_WHEEL_DEVICES_EXCLUDED          = "SDL_JOYSTICK_WHEEL_DEVICES_EXCLUDED";
const Hint JOYSTICK_ZERO_CENTERED_DEVICES           = "SDL_JOYSTICK_ZERO_CENTERED_DEVICES";
const Hint KEYCODE_OPTIONS                          = "SDL_KEYCODE_OPTIONS";
const Hint KMSDRM_DEVICE_INDEX                      = "SDL_KMSDRM_DEVICE_INDEX";
const Hint KMSDRM_REQUIRE_DRM_MASTER                = "SDL_KMSDRM_REQUIRE_DRM_MASTER";
const Hint LOGGING                                  = "SDL_LOGGING";
const Hint MAC_BACKGROUND_APP                       = "SDL_MAC_BACKGROUND_APP";
const Hint MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK       = "SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK";
const Hint MAC_OPENGL_ASYNC_DISPATCH                = "SDL_MAC_OPENGL_ASYNC_DISPATCH";
const Hint MAIN_CALLBACK_RATE                       = "SDL_MAIN_CALLBACK_RATE";
const Hint MOUSE_AUTO_CAPTURE                       = "SDL_MOUSE_AUTO_CAPTURE";
const Hint MOUSE_DOUBLE_CLICK_RADIUS                = "SDL_MOUSE_DOUBLE_CLICK_RADIUS";
const Hint MOUSE_DOUBLE_CLICK_TIME                  = "SDL_MOUSE_DOUBLE_CLICK_TIME";
const Hint MOUSE_EMULATE_WARP_WITH_RELATIVE         = "SDL_MOUSE_EMULATE_WARP_WITH_RELATIVE";
const Hint MOUSE_FOCUS_CLICKTHROUGH                 = "SDL_MOUSE_FOCUS_CLICKTHROUGH";
const Hint MOUSE_NORMAL_SPEED_SCALE                 = "SDL_MOUSE_NORMAL_SPEED_SCALE";
const Hint MOUSE_RELATIVE_MODE_CENTER               = "SDL_MOUSE_RELATIVE_MODE_CENTER";
const Hint MOUSE_RELATIVE_MODE_WARP                 = "SDL_MOUSE_RELATIVE_MODE_WARP";
const Hint MOUSE_RELATIVE_SPEED_SCALE               = "SDL_MOUSE_RELATIVE_SPEED_SCALE";
const Hint MOUSE_RELATIVE_SYSTEM_SCALE              = "SDL_MOUSE_RELATIVE_SYSTEM_SCALE";
const Hint MOUSE_RELATIVE_WARP_MOTION               = "SDL_MOUSE_RELATIVE_WARP_MOTION";
const Hint MOUSE_RELATIVE_CURSOR_VISIBLE            = "SDL_MOUSE_RELATIVE_CURSOR_VISIBLE";
const Hint MOUSE_RELATIVE_CLIP_INTERVAL             = "SDL_MOUSE_RELATIVE_CLIP_INTERVAL";
const Hint MOUSE_TOUCH_EVENTS                       = "SDL_MOUSE_TOUCH_EVENTS";
const Hint MUTE_CONSOLE_KEYBOARD                    = "SDL_MUTE_CONSOLE_KEYBOARD";
const Hint NO_SIGNAL_HANDLERS                       = "SDL_NO_SIGNAL_HANDLERS";
const Hint OPENGL_LIBRARY                           = "SDL_OPENGL_LIBRARY";
const Hint OPENGL_ES_DRIVER                         = "SDL_OPENGL_ES_DRIVER";
const Hint ORIENTATIONS                             = "SDL_ORIENTATIONS";
const Hint PEN_DELAY_MOUSE_BUTTON                   = "SDL_PEN_DELAY_MOUSE_BUTTON";
const Hint PEN_NOT_MOUSE                            = "SDL_PEN_NOT_MOUSE";
const Hint POLL_SENTINEL                            = "SDL_POLL_SENTINEL";
const Hint PREFERRED_LOCALES                        = "SDL_PREFERRED_LOCALES";
const Hint QUIT_ON_LAST_WINDOW_CLOSE                = "SDL_QUIT_ON_LAST_WINDOW_CLOSE";
const Hint RENDER_DIRECT3D_THREADSAFE               = "SDL_RENDER_DIRECT3D_THREADSAFE";
const Hint RENDER_DIRECT3D11_DEBUG                  = "SDL_RENDER_DIRECT3D11_DEBUG";
const Hint RENDER_VULKAN_DEBUG                      = "SDL_RENDER_VULKAN_DEBUG";
const Hint RENDER_DRIVER                            = "SDL_RENDER_DRIVER";
const Hint RENDER_LINE_METHOD                       = "SDL_RENDER_LINE_METHOD";
const Hint RENDER_METAL_PREFER_LOW_POWER_DEVICE     = "SDL_RENDER_METAL_PREFER_LOW_POWER_DEVICE";
const Hint RENDER_VSYNC                             = "SDL_RENDER_VSYNC";
const Hint RETURN_KEY_HIDES_IME                     = "SDL_RETURN_KEY_HIDES_IME";
const Hint ROG_GAMEPAD_MICE                         = "SDL_ROG_GAMEPAD_MICE";
const Hint ROG_GAMEPAD_MICE_EXCLUDED                = "SDL_ROG_GAMEPAD_MICE_EXCLUDED";
const Hint RPI_VIDEO_LAYER                          = "SDL_RPI_VIDEO_LAYER";
const Hint SCREENSAVER_INHIBIT_ACTIVITY_NAME        = "SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME";
const Hint SHUTDOWN_DBUS_ON_QUIT                    = "SDL_SHUTDOWN_DBUS_ON_QUIT";
const Hint STORAGE_TITLE_DRIVER                     = "SDL_STORAGE_TITLE_DRIVER";
const Hint STORAGE_USER_DRIVER                      = "SDL_STORAGE_USER_DRIVER";
const Hint THREAD_FORCE_REALTIME_TIME_CRITICAL      = "SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL";
const Hint THREAD_PRIORITY_POLICY                   = "SDL_THREAD_PRIORITY_POLICY";
const Hint TIMER_RESOLUTION                         = "SDL_TIMER_RESOLUTION";
const Hint TOUCH_MOUSE_EVENTS                       = "SDL_TOUCH_MOUSE_EVENTS";
const Hint TRACKPAD_IS_TOUCH_ONLY                   = "SDL_TRACKPAD_IS_TOUCH_ONLY";
const Hint TV_REMOTE_AS_JOYSTICK                    = "SDL_TV_REMOTE_AS_JOYSTICK";
const Hint VIDEO_ALLOW_SCREENSAVER                  = "SDL_VIDEO_ALLOW_SCREENSAVER";
const Hint VIDEO_DOUBLE_BUFFER                      = "SDL_VIDEO_DOUBLE_BUFFER";
const Hint VIDEO_DRIVER                             = "SDL_VIDEO_DRIVER";
const Hint VIDEO_DUMMY_SAVE_FRAMES                  = "SDL_VIDEO_DUMMY_SAVE_FRAMES";
const Hint VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK      = "SDL_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK";
const Hint VIDEO_FORCE_EGL                          = "SDL_VIDEO_FORCE_EGL";
const Hint VIDEO_MAC_FULLSCREEN_SPACES              = "SDL_VIDEO_MAC_FULLSCREEN_SPACES";
const Hint VIDEO_MINIMIZE_ON_FOCUS_LOSS             = "SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS";
const Hint VIDEO_OFFSCREEN_SAVE_FRAMES              = "SDL_VIDEO_OFFSCREEN_SAVE_FRAMES";
const Hint VIDEO_SYNC_WINDOW_OPERATIONS             = "SDL_VIDEO_SYNC_WINDOW_OPERATIONS";
const Hint VIDEO_WAYLAND_ALLOW_LIBDECOR             = "SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR";
const Hint VIDEO_WAYLAND_MODE_EMULATION             = "SDL_VIDEO_WAYLAND_MODE_EMULATION";
const Hint VIDEO_WAYLAND_MODE_SCALING               = "SDL_VIDEO_WAYLAND_MODE_SCALING";
const Hint VIDEO_WAYLAND_PREFER_LIBDECOR            = "SDL_VIDEO_WAYLAND_PREFER_LIBDECOR";
const Hint VIDEO_WAYLAND_SCALE_TO_DISPLAY           = "SDL_VIDEO_WAYLAND_SCALE_TO_DISPLAY";
const Hint VIDEO_WIN_D3DCOMPILER                    = "SDL_VIDEO_WIN_D3DCOMPILER";
const Hint VIDEO_X11_NET_WM_BYPASS_COMPOSITOR       = "SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR";
const Hint VIDEO_X11_NET_WM_PING                    = "SDL_VIDEO_X11_NET_WM_PING";
const Hint VIDEO_X11_NODIRECTCOLOR                  = "SDL_VIDEO_X11_NODIRECTCOLOR";
const Hint VIDEO_X11_SCALING_FACTOR                 = "SDL_VIDEO_X11_SCALING_FACTOR";
const Hint VIDEO_X11_VISUALID                       = "SDL_VIDEO_X11_VISUALID";
const Hint VIDEO_X11_WINDOW_VISUALID                = "SDL_VIDEO_X11_WINDOW_VISUALID";
const Hint VIDEO_X11_XRANDR                         = "SDL_VIDEO_X11_XRANDR";
const Hint VITA_ENABLE_BACK_TOUCH                   = "SDL_VITA_ENABLE_BACK_TOUCH";
const Hint VITA_ENABLE_FRONT_TOUCH                  = "SDL_VITA_ENABLE_FRONT_TOUCH";
const Hint VITA_MODULE_PATH                         = "SDL_VITA_MODULE_PATH";
const Hint VITA_PVR_INIT                            = "SDL_VITA_PVR_INIT";
const Hint VITA_RESOLUTION                          = "SDL_VITA_RESOLUTION";
const Hint VITA_PVR_OPENGL                          = "SDL_VITA_PVR_OPENGL";
const Hint VITA_TOUCH_MOUSE_DEVICE                  = "SDL_VITA_TOUCH_MOUSE_DEVICE";
const Hint VULKAN_DISPLAY                           = "SDL_VULKAN_DISPLAY";
const Hint VULKAN_LIBRARY                           = "SDL_VULKAN_LIBRARY";
const Hint WAVE_FACT_CHUNK                          = "SDL_WAVE_FACT_CHUNK";
const Hint WAVE_CHUNK_LIMIT                         = "SDL_WAVE_CHUNK_LIMIT";
const Hint WAVE_RIFF_CHUNK_SIZE                     = "SDL_WAVE_RIFF_CHUNK_SIZE";
const Hint WAVE_TRUNCATION                          = "SDL_WAVE_TRUNCATION";
const Hint WINDOW_ACTIVATE_WHEN_RAISED              = "SDL_WINDOW_ACTIVATE_WHEN_RAISED";
const Hint WINDOW_ACTIVATE_WHEN_SHOWN               = "SDL_WINDOW_ACTIVATE_WHEN_SHOWN";
const Hint WINDOW_ALLOW_TOPMOST                     = "SDL_WINDOW_ALLOW_TOPMOST";
const Hint WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN  = "SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN";
const Hint WINDOWS_CLOSE_ON_ALT_F4                  = "SDL_WINDOWS_CLOSE_ON_ALT_F4";
const Hint WINDOWS_ENABLE_MENU_MNEMONICS            = "SDL_WINDOWS_ENABLE_MENU_MNEMONICS";
const Hint WINDOWS_ENABLE_MESSAGELOOP               = "SDL_WINDOWS_ENABLE_MESSAGELOOP";
const Hint WINDOWS_GAMEINPUT                        = "SDL_WINDOWS_GAMEINPUT";
const Hint WINDOWS_RAW_KEYBOARD                     = "SDL_WINDOWS_RAW_KEYBOARD";
const Hint WINDOWS_FORCE_SEMAPHORE_KERNEL           = "SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL";
const Hint WINDOWS_INTRESOURCE_ICON                 = "SDL_WINDOWS_INTRESOURCE_ICON";
const Hint WINDOWS_INTRESOURCE_ICON_SMALL           = "SDL_WINDOWS_INTRESOURCE_ICON_SMALL";
const Hint WINDOWS_USE_D3D9EX                       = "SDL_WINDOWS_USE_D3D9EX";
const Hint WINDOWS_ERASE_BACKGROUND_MODE            = "SDL_WINDOWS_ERASE_BACKGROUND_MODE";
const Hint WINRT_HANDLE_BACK_BUTTON                 = "SDL_WINRT_HANDLE_BACK_BUTTON";
const Hint WINRT_PRIVACY_POLICY_LABEL               = "SDL_WINRT_PRIVACY_POLICY_LABEL";
const Hint WINRT_PRIVACY_POLICY_URL                 = "SDL_WINRT_PRIVACY_POLICY_URL";
const Hint X11_FORCE_OVERRIDE_REDIRECT              = "SDL_X11_FORCE_OVERRIDE_REDIRECT";
const Hint X11_WINDOW_TYPE                          = "SDL_X11_WINDOW_TYPE";
const Hint X11_XCB_LIBRARY                          = "SDL_X11_XCB_LIBRARY";
const Hint XINPUT_ENABLED                           = "SDL_XINPUT_ENABLED";

module sdl3;

distinct InitFlag = uint;
distinct MetadataProperty = inline char*;

fn ZString get_app_metadata_property(MetadataProperty name) @extern("SDL_GetAppMetadataProperty");
fn int init(InitFlag) @extern("SDL_Init");
fn int init_subsystem(InitFlag) @extern("SDL_InitSubSystem");
fn void quit() @extern("SDL_Quit");
fn void quit_subsystem(InitFlag) @extern("SDL_QuitSubSystem");
fn int set_app_metadata(ZString appname, ZString appversion, ZString appidentifier) @extern("SDL_SetAppMetadata");
fn int set_app_metadata_property(MetadataProperty name, ZString value) @extern("SDL_SetAppMetadataProperty");
fn InitFlag was_init(InitFlag) @extern("SDL_WasInit");

module sdl3::subsystem;

const InitFlag TIMER    = 0x00000001u;
const InitFlag AUDIO    = 0x00000010u;
const InitFlag VIDEO    = 0x00000020u;
const InitFlag JOYSTICK = 0x00000200u;
const InitFlag HAPTIC   = 0x00001000u;
const InitFlag GAMEPAD  = 0x00002000u;
const InitFlag EVENTS   = 0x00004000u;
const InitFlag SENSOR   = 0x00008000u;
const InitFlag CAMERA   = 0x00010000u;

module sdl3::metadata_property;

const MetadataProperty NAME        =  "SDL_PROP_APP_METADATA_NAME_STRING";
const MetadataProperty VERSION     =  "SDL_PROP_APP_METADATA_VERSION_STRING";
const MetadataProperty IDENTIFIER  =  "SDL_PROP_APP_METADATA_IDENTIFIER_STRING";
const MetadataProperty CREATOR     =  "SDL_PROP_APP_METADATA_CREATOR_STRING";
const MetadataProperty COPYRIGHT   =  "SDL_PROP_APP_METADATA_COPYRIGHT_STRING";
const MetadataProperty URL         =  "SDL_PROP_APP_METADATA_URL_STRING";
const MetadataProperty TYPE        =  "SDL_PROP_APP_METADATA_TYPE_STRING";

module sdl3;

distinct IOStream = void*;
distinct IOStatus = uint;
distinct IOWhence = uint;

def StreamCloseCallback = fn int (void* userdata);
def StreamReadCallback  = fn usz (void* userdata, void* ptr, usz size, IOStatus* status);
def StreamSeekCallback  = fn long (void* userdata, long offset, IOWhence whence);
def StreamSizeCallback  = fn long (void* userdata);
def StreamWriteCallback = fn usz (void* userdata, void* ptr, usz size, IOStatus* status);

struct IOStreamInterface
{
    StreamSizeCallback  size_callback;
    StreamSeekCallback  seek_callback;
    StreamReadCallback  read_callback;
    StreamWriteCallback write_callback;
    StreamCloseCallback close_callback;
}

fn int close_io(IOStream* context) @extern("SDL_CloseIO");
fn PropertiesID get_io_properties(IOStream* context) @extern("SDL_GetIOProperties");
fn long get_io_size(IOStream* context) @extern("SDL_GetIOSize");
fn IOStatus get_io_status(IOStream* context) @extern("SDL_GetIOStatus");
fn IOStream* io_from_const_mem(void* mem, usz size) @extern("SDL_IOFromConstMem");
fn IOStream* io_from_dynamic_mem() @extern("SDL_IOFromDynamicMem");
fn IOStream* io_from_file(ZString file, ZString mode) @extern("SDL_IOFromFile");
fn IOStream io_from_mem(void* mem, usz size) @extern("SDL_IOFromMem");
fn usz i_oprintf(IOStream* context, ZString fmt, ...) @extern("SDL_IOprintf");
// fn usz i_ovprintf(IOStream* context, ZString fmt, va_list ap) @extern("SDL_IOvprintf");
fn void* load_file(ZString file, usz* datasize) @extern("SDL_LoadFile");
fn void* load_file_io(IOStream* src, usz* datasize, bool closeio) @extern("SDL_LoadFile_IO");
fn IOStream* open_io(IOStreamInterface* iface, void* userdata) @extern("SDL_OpenIO");
fn usz read_io(IOStream* context, void* ptr, usz size) @extern("SDL_ReadIO");
fn bool read_s16be(IOStream* src, short* value) @extern("SDL_ReadS16BE");
fn bool read_s16le(IOStream* src, short* value) @extern("SDL_ReadS16LE");
fn bool read_s32be(IOStream* src, int* value) @extern("SDL_ReadS32BE");
fn bool read_s32le(IOStream* src, int* value) @extern("SDL_ReadS32LE");
fn bool read_s64be(IOStream* src, long* value) @extern("SDL_ReadS64BE");
fn bool read_s64le(IOStream* src, long* value) @extern("SDL_ReadS64LE");
fn bool read_s8(IOStream* src, ichar* value) @extern("SDL_ReadS8");
fn bool read_u16be(IOStream* src, ushort* value) @extern("SDL_ReadU16BE");
fn bool read_u16le(IOStream* src, ushort* value) @extern("SDL_ReadU16LE");
fn bool read_u32be(IOStream* src, uint* value) @extern("SDL_ReadU32BE");
fn bool read_u32le(IOStream* src, uint* value) @extern("SDL_ReadU32LE");
fn bool read_u64be(IOStream* src, ulong* value) @extern("SDL_ReadU64BE");
fn bool read_u64le(IOStream* src, ulong* value) @extern("SDL_ReadU64LE");
fn bool read_u8(IOStream* src, char  * value) @extern("SDL_ReadU8");
fn long seek_io(IOStream* context, long offset, IOWhence whence) @extern("SDL_SeekIO");
fn long tell_io(IOStream* context) @extern("SDL_TellIO");
fn usz write_io(IOStream* context, void* ptr, usz size) @extern("SDL_WriteIO");
fn bool write_s16be(IOStream* dst, short value) @extern("SDL_WriteS16BE");
fn bool write_s16le(IOStream* dst, short value) @extern("SDL_WriteS16LE");
fn bool write_s32be(IOStream* dst, int value) @extern("SDL_WriteS32BE");
fn bool write_s32le(IOStream* dst, int value) @extern("SDL_WriteS32LE");
fn bool write_s64be(IOStream* dst, long value) @extern("SDL_WriteS64BE");
fn bool write_s64le(IOStream* dst, long value) @extern("SDL_WriteS64LE");
fn bool write_s8(IOStream* dst, ichar value) @extern("SDL_WriteS8");
fn bool write_u16be(IOStream* dst, ushort value) @extern("SDL_WriteU16BE");
fn bool write_u16le(IOStream* dst, ushort value) @extern("SDL_WriteU16LE");
fn bool write_u32be(IOStream* dst, uint value) @extern("SDL_WriteU32BE");
fn bool write_u32le(IOStream* dst, uint value) @extern("SDL_WriteU32LE");
fn bool write_u64be(IOStream* dst, ulong value) @extern("SDL_WriteU64BE");
fn bool write_u64le(IOStream* dst, ulong value) @extern("SDL_WriteU64LE");
fn bool write_u8(IOStream* dst, char value) @extern("SDL_WriteU8");

module sdl3::io_status;

const IOStatus READY      =  0;
const IOStatus ERROR      =  1;
const IOStatus EOF        =  2;
const IOStatus NOT_READY  =  3;
const IOStatus READONLY   =  4;
const IOStatus WRITEONLY  =  5;

module sdl3::io_whence;

const IOWhence SEEK_SET  =  0;
const IOWhence SEEK_CUR  =  1;
const IOWhence SEEK_END  =  2;

module sdl3;

const int JOYSTICK_AXIS_MAX =  32767;
const int JOYSTICK_AXIS_MIN = -32768;

distinct Joystick = void*;
distinct JoystickConnectionState = int;
distinct JoystickHat = uint;
distinct JoystickID = uint;
distinct JoystickType = uint;

def VirtualJoystickUpdateCallback            = fn void(void* userdata);
def VirtualJoystickSetPlayerIndexCallback    = fn void(void* userdata, int player_index);
def VirtualJoystickRumbleCallabck            = fn int (void* userdata, ushort low_frequency_rumble, ushort high_frequency_rumble);
def VirtualJoystickRumbleTriggersCallabck    = fn int (void* userdata, ushort left_rumble, ushort right_rumble);
def VirtualJoystickSetLEDCallabck            = fn int (void* userdata, char red, char green, char blue);
def VirtualJoystickSendEffectCallabck        = fn int (void* userdata, void* data, int size);
def VirtualJoystickSetSensorsEnabledCallabck = fn int (void* userdata, bool enabled);

struct VirtualJoystickDesc
{
    ushort type;
    ushort padding;
    ushort vendor_id;
    ushort product_id;
    ushort naxes;
    ushort nbuttons;
    ushort nballs;
    ushort nhats;
    ushort ntouchpads;
    ushort nsensors;
    ushort[2] padding2;
    uint button_mask;
    uint axis_mask;
    ZString name;
    
    VirtualJoystickTouchpadDesc* touchpads;
    VirtualJoystickSensorDesc* sensors;

    void* userdata;
    
    VirtualJoystickUpdateCallback             update;
    VirtualJoystickSetPlayerIndexCallback     set_player_index;
    VirtualJoystickRumbleCallabck             rumble;
    VirtualJoystickRumbleTriggersCallabck     rumble_triggers;
    VirtualJoystickSetLEDCallabck             set_led;
    VirtualJoystickSendEffectCallabck         send_effect;
    VirtualJoystickSetSensorsEnabledCallabck  set_sensors_enabled;
}

struct VirtualJoystickSensorDesc
{
    SensorType type;
    float rate;
}

struct VirtualJoystickTouchpadDesc
{
    ushort nfingers;
    ushort[3] padding;
}

fn JoystickID attach_virtual_joystick(VirtualJoystickDesc* desc) @extern("SDL_AttachVirtualJoystick");
fn void close_joystick(Joystick* joystick) @extern("SDL_CloseJoystick");
fn int detach_virtual_joystick(JoystickID instance_id) @extern("SDL_DetachVirtualJoystick");
fn short get_joystick_axis(Joystick* joystick, int axis) @extern("SDL_GetJoystickAxis");
fn bool get_joystick_axis_initial_state(Joystick* joystick, int axis, short* state) @extern("SDL_GetJoystickAxisInitialState");
fn int get_joystick_ball(Joystick* joystick, int ball, int* dx, int* dy) @extern("SDL_GetJoystickBall");
fn uint get_joystick_button(Joystick* joystick, int button) @extern("SDL_GetJoystickButton");
fn JoystickConnectionState get_joystick_connection_state(Joystick* joystick) @extern("SDL_GetJoystickConnectionState");
fn ushort get_joystick_firmware_version(Joystick* joystick) @extern("SDL_GetJoystickFirmwareVersion");
fn Joystick* get_joystick_from_id(JoystickID instance_id) @extern("SDL_GetJoystickFromID");
fn Joystick* get_joystick_from_player_index(int player_index) @extern("SDL_GetJoystickFromPlayerIndex");
fn Guid get_joystick_guid(Joystick* joystick) @extern("SDL_GetJoystickGUID");
fn Guid get_joystick_guid_for_id(JoystickID instance_id) @extern("SDL_GetJoystickGUIDForID");
fn void get_joystick_guid_info(Guid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16) @extern("SDL_GetJoystickGUIDInfo");
fn char get_joystick_hat(Joystick* joystick, JoystickHat hat) @extern("SDL_GetJoystickHat");
fn JoystickID get_joystick_id(Joystick* joystick) @extern("SDL_GetJoystickID");
fn ZString get_joystick_name(Joystick* joystick) @extern("SDL_GetJoystickName");
fn ZString get_joystick_name_for_id(JoystickID instance_id) @extern("SDL_GetJoystickNameForID");
fn ZString get_joystick_path(Joystick* joystick) @extern("SDL_GetJoystickPath");
fn ZString get_joystick_path_for_id(JoystickID instance_id) @extern("SDL_GetJoystickPathForID");
fn int get_joystick_player_index(Joystick* joystick) @extern("SDL_GetJoystickPlayerIndex");
fn int get_joystick_player_index_for_id(JoystickID instance_id) @extern("SDL_GetJoystickPlayerIndexForID");
fn PowerState get_joystick_power_info(Joystick* joystick, int* percent) @extern("SDL_GetJoystickPowerInfo");
fn ushort get_joystick_product(Joystick* joystick) @extern("SDL_GetJoystickProduct");
fn ushort get_joystick_product_for_id(JoystickID instance_id) @extern("SDL_GetJoystickProductForID");
fn ushort get_joystick_product_version(Joystick* joystick) @extern("SDL_GetJoystickProductVersion");
fn ushort get_joystick_product_version_for_id(JoystickID instance_id) @extern("SDL_GetJoystickProductVersionForID");
fn PropertiesID get_joystick_properties(Joystick* joystick) @extern("SDL_GetJoystickProperties");
fn JoystickID get_joysticks(int* count) @extern("SDL_GetJoysticks");
fn ZString get_joystick_serial(Joystick* joystick) @extern("SDL_GetJoystickSerial");
fn JoystickType get_joystick_type(Joystick* joystick) @extern("SDL_GetJoystickType");
fn JoystickType get_joystick_type_for_id(JoystickID instance_id) @extern("SDL_GetJoystickTypeForID");
fn ushort get_joystick_vendor(Joystick* joystick) @extern("SDL_GetJoystickVendor");
fn ushort get_joystick_vendor_for_id(JoystickID instance_id) @extern("SDL_GetJoystickVendorForID");
fn int get_num_joystick_axes(Joystick* joystick) @extern("SDL_GetNumJoystickAxes");
fn int get_num_joystick_balls(Joystick* joystick) @extern("SDL_GetNumJoystickBalls");
fn int get_num_joystick_buttons(Joystick* joystick) @extern("SDL_GetNumJoystickButtons");
fn int get_num_joystick_hats(Joystick* joystick) @extern("SDL_GetNumJoystickHats");
fn bool has_joystick() @extern("SDL_HasJoystick");
fn bool is_joystick_virtual(JoystickID instance_id) @extern("SDL_IsJoystickVirtual");
fn bool joystick_connected(Joystick* joystick) @extern("SDL_JoystickConnected");
fn bool joystick_events_enabled(Joystick* joystick) @extern("SDL_JoystickEventsEnabled");
fn void lock_joysticks() @extern("SDL_LockJoysticks");
fn Joystick* open_joystick(JoystickID instance_id) @extern("SDL_OpenJoystick");
fn int rumble_joystick(Joystick* joystick, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms) @extern("SDL_RumbleJoystick");
fn int rumble_joystick_triggers(Joystick* joystick, ushort left_rumble, ushort right_rumble, uint duration_ms) @extern("SDL_RumbleJoystickTriggers");
fn int send_joystick_effect(Joystick* joystick, void* data, int size) @extern("SDL_SendJoystickEffect");
fn int send_joystick_virtual_sensor_data(Joystick* joystick, SensorType type, ulong sensor_timestamp, float* data, int num_values) @extern("SDL_SendJoystickVirtualSensorData");
fn void set_joystick_events_enabled(bool enabled) @extern("SDL_SetJoystickEventsEnabled");
fn int set_joystick_led(Joystick* joystick, char red, char green, char blue) @extern("SDL_SetJoystickLED");
fn int set_joystick_player_index(Joystick* joystick, int player_index) @extern("SDL_SetJoystickPlayerIndex");
fn int set_joystick_virtual_axis(Joystick* joystick, int axis, short value) @extern("SDL_SetJoystickVirtualAxis");
fn int set_joystick_virtual_ball(Joystick* joystick, int ball, short xrel, short yrel) @extern("SDL_SetJoystickVirtualBall");
fn int set_joystick_virtual_button(Joystick* joystick, int button, char value) @extern("SDL_SetJoystickVirtualButton");
fn int set_joystick_virtual_hat(Joystick* joystick, int hat, char value) @extern("SDL_SetJoystickVirtualHat");
fn int set_joystick_virtual_touchpad(Joystick* joystick, int touchpad, int finger, char state, float x, float y, float pressure) @extern("SDL_SetJoystickVirtualTouchpad");
fn void unlock_joysticks() @extern("SDL_UnlockJoysticks");
fn void update_joysticks() @extern("SDL_UpdateJoysticks");

module sdl3::joystick_connection_state;

const JoystickConnectionState INVALID   =  -1;
const JoystickConnectionState UNKNOWN   =   0;
const JoystickConnectionState WIRED     =   1;
const JoystickConnectionState WIRELESS  =   2;

module sdl3::joystick_hat;

const JoystickHat CENTERED   =  0x00u;
const JoystickHat UP         =  0x01u;
const JoystickHat RIGHT      =  0x02u;
const JoystickHat DOWN       =  0x04u;
const JoystickHat LEFT       =  0x08u;
const JoystickHat RIGHTUP    =  (RIGHT|UP);
const JoystickHat RIGHTDOWN  =  (RIGHT|DOWN);
const JoystickHat LEFTUP     =  (LEFT|UP);
const JoystickHat LEFTDOWN   =  (LEFT|DOWN);

module sdl3::joystick_type;

const JoystickType UNKNOWN       = 0;
const JoystickType GAMEPAD       = 1;
const JoystickType WHEEL         = 2;
const JoystickType ARCADE_STICK  = 3;
const JoystickType FLIGHT_STICK  = 4;
const JoystickType DANCE_PAD     = 5;
const JoystickType GUITAR        = 6;
const JoystickType DRUM_KIT      = 7;
const JoystickType ARCADE_PAD    = 8;
const JoystickType THROTTLE      = 9;

module sdl3;

distinct KeyboardID = uint;
distinct Capitalization = uint;
distinct TextInputType = uint;

fn int clear_composition(Window* window) @extern("SDL_ClearComposition");
fn Window* get_keyboard_focus() @extern("SDL_GetKeyboardFocus");
fn ZString get_keyboard_name_for_id(KeyboardID instance_id) @extern("SDL_GetKeyboardNameForID");
fn KeyboardID* get_keyboards(int* count) @extern("SDL_GetKeyboards");
fn ZString get_keyboard_state(int* numkeys) @extern("SDL_GetKeyboardState");
fn Keycode get_key_from_name(ZString name) @extern("SDL_GetKeyFromName");
fn Keycode get_key_from_scancode(Scancode scancode, Keymod modstate, bool key_event) @extern("SDL_GetKeyFromScancode");
fn ZString get_key_name(Keycode key) @extern("SDL_GetKeyName");
fn Keymod get_mod_state() @extern("SDL_GetModState");
fn Scancode get_scancode_from_key(Keycode key, Keymod* modstate) @extern("SDL_GetScancodeFromKey");
fn Scancode get_scancode_from_name(ZString name) @extern("SDL_GetScancodeFromName");
fn ZString get_scancode_name(Scancode scancode) @extern("SDL_GetScancodeName");
fn int get_text_input_area(Window* window, Rect* rect, int* cursor) @extern("SDL_GetTextInputArea");
fn bool has_keyboard() @extern("SDL_HasKeyboard");
fn bool has_screen_keyboard_support() @extern("SDL_HasScreenKeyboardSupport");
fn void reset_keyboard() @extern("SDL_ResetKeyboard");
fn bool screen_keyboard_shown(Window* window) @extern("SDL_ScreenKeyboardShown");
fn void set_mod_state(Keymod modstate) @extern("SDL_SetModState");
fn int set_scancode_name(Scancode scancode, ZString name) @extern("SDL_SetScancodeName");
fn int set_text_input_area(Window* window, Rect* rect, int cursor) @extern("SDL_SetTextInputArea");
fn int start_text_input(Window* window) @extern("SDL_StartTextInput");
fn int start_text_input_with_properties(Window* window, PropertiesID props) @extern("SDL_StartTextInputWithProperties");
fn int stop_text_input(Window* window) @extern("SDL_StopTextInput");
fn bool text_input_active(Window* window) @extern("SDL_TextInputActive");

module sdl3::capitalization;

const Capitalization NONE       = 0;
const Capitalization SENTENCES  = 1;
const Capitalization WORDS      = 2;
const Capitalization LETTERS    = 3;

module sdl3::text_input_type;

const TextInputType TEXT                     =  0;
const TextInputType TEXT_NAME                =  1;
const TextInputType TEXT_EMAIL               =  2;
const TextInputType TEXT_USERNAME            =  3;
const TextInputType TEXT_PASSWORD_HIDDEN     =  4;
const TextInputType TEXT_PASSWORD_VISIBLE    =  5;
const TextInputType NUMBER                   =  6;
const TextInputType NUMBER_PASSWORD_HIDDEN   =  7;
const TextInputType NUMBER_PASSWORD_VISIBLE  =  8;

module sdl3;

distinct Keycode = uint;
distinct Keymod = ushort;

const SCANCODE_MASK  =  (1u<<30);

macro Keycode scancode_to_keycode(Scancode x)
{
    return (Keycode)((uint)x  | SCANCODE_MASK );
}

module sdl3::keycode;

const Keycode SDLK_UNKNOWN               =  0x00000000u; // 0
const Keycode SDLK_RETURN                =  0x0000000du; // '\r'
const Keycode SDLK_ESCAPE                =  0x0000001bu; // '\x1B'
const Keycode SDLK_BACKSPACE             =  0x00000008u; // '\b'
const Keycode SDLK_TAB                   =  0x00000009u; // '\t'
const Keycode SDLK_SPACE                 =  0x00000020u; // ' '
const Keycode SDLK_EXCLAIM               =  0x00000021u; // '!'
const Keycode SDLK_DBLAPOSTROPHE         =  0x00000022u; // '"'
const Keycode SDLK_HASH                  =  0x00000023u; // '#'
const Keycode SDLK_DOLLAR                =  0x00000024u; // '$'
const Keycode SDLK_PERCENT               =  0x00000025u; // '%'
const Keycode SDLK_AMPERSAND             =  0x00000026u; // '&'
const Keycode SDLK_APOSTROPHE            =  0x00000027u; // '\''
const Keycode SDLK_LEFTPAREN             =  0x00000028u; // '('
const Keycode SDLK_RIGHTPAREN            =  0x00000029u; // ')'
const Keycode SDLK_ASTERISK              =  0x0000002au; // '*'
const Keycode SDLK_PLUS                  =  0x0000002bu; // '+'
const Keycode SDLK_COMMA                 =  0x0000002cu; // ','
const Keycode SDLK_MINUS                 =  0x0000002du; // '-'
const Keycode SDLK_PERIOD                =  0x0000002eu; // '.'
const Keycode SDLK_SLASH                 =  0x0000002fu; // '/'
const Keycode SDLK_0                     =  0x00000030u; // '0'
const Keycode SDLK_1                     =  0x00000031u; // '1'
const Keycode SDLK_2                     =  0x00000032u; // '2'
const Keycode SDLK_3                     =  0x00000033u; // '3'
const Keycode SDLK_4                     =  0x00000034u; // '4'
const Keycode SDLK_5                     =  0x00000035u; // '5'
const Keycode SDLK_6                     =  0x00000036u; // '6'
const Keycode SDLK_7                     =  0x00000037u; // '7'
const Keycode SDLK_8                     =  0x00000038u; // '8'
const Keycode SDLK_9                     =  0x00000039u; // '9'
const Keycode SDLK_COLON                 =  0x0000003au; // ':'
const Keycode SDLK_SEMICOLON             =  0x0000003bu; // ';'
const Keycode SDLK_LESS                  =  0x0000003cu; // '<'
const Keycode SDLK_EQUALS                =  0x0000003du; // '='
const Keycode SDLK_GREATER               =  0x0000003eu; // '>'
const Keycode SDLK_QUESTION              =  0x0000003fu; // '?'
const Keycode SDLK_AT                    =  0x00000040u; // '@'
const Keycode SDLK_LEFTBRACKET           =  0x0000005bu; // '['
const Keycode SDLK_BACKSLASH             =  0x0000005cu; // '\\'
const Keycode SDLK_RIGHTBRACKET          =  0x0000005du; // ']'
const Keycode SDLK_CARET                 =  0x0000005eu; // '^'
const Keycode SDLK_UNDERSCORE            =  0x0000005fu; // '_'
const Keycode SDLK_GRAVE                 =  0x00000060u; // '`'
const Keycode SDLK_A                     =  0x00000061u; // 'a'
const Keycode SDLK_B                     =  0x00000062u; // 'b'
const Keycode SDLK_C                     =  0x00000063u; // 'c'
const Keycode SDLK_D                     =  0x00000064u; // 'd'
const Keycode SDLK_E                     =  0x00000065u; // 'e'
const Keycode SDLK_F                     =  0x00000066u; // 'f'
const Keycode SDLK_G                     =  0x00000067u; // 'g'
const Keycode SDLK_H                     =  0x00000068u; // 'h'
const Keycode SDLK_I                     =  0x00000069u; // 'i'
const Keycode SDLK_J                     =  0x0000006au; // 'j'
const Keycode SDLK_K                     =  0x0000006bu; // 'k'
const Keycode SDLK_L                     =  0x0000006cu; // 'l'
const Keycode SDLK_M                     =  0x0000006du; // 'm'
const Keycode SDLK_N                     =  0x0000006eu; // 'n'
const Keycode SDLK_O                     =  0x0000006fu; // 'o'
const Keycode SDLK_P                     =  0x00000070u; // 'p'
const Keycode SDLK_Q                     =  0x00000071u; // 'q'
const Keycode SDLK_R                     =  0x00000072u; // 'r'
const Keycode SDLK_S                     =  0x00000073u; // 's'
const Keycode SDLK_T                     =  0x00000074u; // 't'
const Keycode SDLK_U                     =  0x00000075u; // 'u'
const Keycode SDLK_V                     =  0x00000076u; // 'v'
const Keycode SDLK_W                     =  0x00000077u; // 'w'
const Keycode SDLK_X                     =  0x00000078u; // 'x'
const Keycode SDLK_Y                     =  0x00000079u; // 'y'
const Keycode SDLK_Z                     =  0x0000007au; // 'z'
const Keycode SDLK_LEFTBRACE             =  0x0000007bu; // '{'
const Keycode SDLK_PIPE                  =  0x0000007cu; // '|'
const Keycode SDLK_RIGHTBRACE            =  0x0000007du; // '}'
const Keycode SDLK_TILDE                 =  0x0000007eu; // '~'
const Keycode SDLK_DELETE                =  0x0000007fu; // '\x7F'
const Keycode SDLK_PLUSMINUS             =  0x000000b1u; // '±'
const Keycode SDLK_CAPSLOCK              =  0x40000039u; // scancode_to_keycode(SC_CAPSLOCK)
const Keycode SDLK_F1                    =  0x4000003au; // scancode_to_keycode(SC_F1)
const Keycode SDLK_F2                    =  0x4000003bu; // scancode_to_keycode(SC_F2)
const Keycode SDLK_F3                    =  0x4000003cu; // scancode_to_keycode(SC_F3)
const Keycode SDLK_F4                    =  0x4000003du; // scancode_to_keycode(SC_F4)
const Keycode SDLK_F5                    =  0x4000003eu; // scancode_to_keycode(SC_F5)
const Keycode SDLK_F6                    =  0x4000003fu; // scancode_to_keycode(SC_F6)
const Keycode SDLK_F7                    =  0x40000040u; // scancode_to_keycode(SC_F7)
const Keycode SDLK_F8                    =  0x40000041u; // scancode_to_keycode(SC_F8)
const Keycode SDLK_F9                    =  0x40000042u; // scancode_to_keycode(SC_F9)
const Keycode SDLK_F10                   =  0x40000043u; // scancode_to_keycode(SC_F10)
const Keycode SDLK_F11                   =  0x40000044u; // scancode_to_keycode(SC_F11)
const Keycode SDLK_F12                   =  0x40000045u; // scancode_to_keycode(SC_F12)
const Keycode SDLK_PRINTSCREEN           =  0x40000046u; // scancode_to_keycode(SC_PRINTSCREEN)
const Keycode SDLK_SCROLLLOCK            =  0x40000047u; // scancode_to_keycode(SC_SCROLLLOCK)
const Keycode SDLK_PAUSE                 =  0x40000048u; // scancode_to_keycode(SC_PAUSE)
const Keycode SDLK_INSERT                =  0x40000049u; // scancode_to_keycode(SC_INSERT)
const Keycode SDLK_HOME                  =  0x4000004au; // scancode_to_keycode(SC_HOME)
const Keycode SDLK_PAGEUP                =  0x4000004bu; // scancode_to_keycode(SC_PAGEUP)
const Keycode SDLK_END                   =  0x4000004du; // scancode_to_keycode(SC_END)
const Keycode SDLK_PAGEDOWN              =  0x4000004eu; // scancode_to_keycode(SC_PAGEDOWN)
const Keycode SDLK_RIGHT                 =  0x4000004fu; // scancode_to_keycode(SC_RIGHT)
const Keycode SDLK_LEFT                  =  0x40000050u; // scancode_to_keycode(SC_LEFT)
const Keycode SDLK_DOWN                  =  0x40000051u; // scancode_to_keycode(SC_DOWN)
const Keycode SDLK_UP                    =  0x40000052u; // scancode_to_keycode(SC_UP)
const Keycode SDLK_NUMLOCKCLEAR          =  0x40000053u; // scancode_to_keycode(SC_NUMLOCKCLEAR)
const Keycode SDLK_KP_DIVIDE             =  0x40000054u; // scancode_to_keycode(SC_KP_DIVIDE)
const Keycode SDLK_KP_MULTIPLY           =  0x40000055u; // scancode_to_keycode(SC_KP_MULTIPLY)
const Keycode SDLK_KP_MINUS              =  0x40000056u; // scancode_to_keycode(SC_KP_MINUS)
const Keycode SDLK_KP_PLUS               =  0x40000057u; // scancode_to_keycode(SC_KP_PLUS)
const Keycode SDLK_KP_ENTER              =  0x40000058u; // scancode_to_keycode(SC_KP_ENTER)
const Keycode SDLK_KP_1                  =  0x40000059u; // scancode_to_keycode(SC_KP_1)
const Keycode SDLK_KP_2                  =  0x4000005au; // scancode_to_keycode(SC_KP_2)
const Keycode SDLK_KP_3                  =  0x4000005bu; // scancode_to_keycode(SC_KP_3)
const Keycode SDLK_KP_4                  =  0x4000005cu; // scancode_to_keycode(SC_KP_4)
const Keycode SDLK_KP_5                  =  0x4000005du; // scancode_to_keycode(SC_KP_5)
const Keycode SDLK_KP_6                  =  0x4000005eu; // scancode_to_keycode(SC_KP_6)
const Keycode SDLK_KP_7                  =  0x4000005fu; // scancode_to_keycode(SC_KP_7)
const Keycode SDLK_KP_8                  =  0x40000060u; // scancode_to_keycode(SC_KP_8)
const Keycode SDLK_KP_9                  =  0x40000061u; // scancode_to_keycode(SC_KP_9)
const Keycode SDLK_KP_0                  =  0x40000062u; // scancode_to_keycode(SC_KP_0)
const Keycode SDLK_KP_PERIOD             =  0x40000063u; // scancode_to_keycode(SC_KP_PERIOD)
const Keycode SDLK_APPLICATION           =  0x40000065u; // scancode_to_keycode(SC_APPLICATION)
const Keycode SDLK_POWER                 =  0x40000066u; // scancode_to_keycode(SC_POWER)
const Keycode SDLK_KP_EQUALS             =  0x40000067u; // scancode_to_keycode(SC_KP_EQUALS)
const Keycode SDLK_F13                   =  0x40000068u; // scancode_to_keycode(SC_F13)
const Keycode SDLK_F14                   =  0x40000069u; // scancode_to_keycode(SC_F14)
const Keycode SDLK_F15                   =  0x4000006au; // scancode_to_keycode(SC_F15)
const Keycode SDLK_F16                   =  0x4000006bu; // scancode_to_keycode(SC_F16)
const Keycode SDLK_F17                   =  0x4000006cu; // scancode_to_keycode(SC_F17)
const Keycode SDLK_F18                   =  0x4000006du; // scancode_to_keycode(SC_F18)
const Keycode SDLK_F19                   =  0x4000006eu; // scancode_to_keycode(SC_F19)
const Keycode SDLK_F20                   =  0x4000006fu; // scancode_to_keycode(SC_F20)
const Keycode SDLK_F21                   =  0x40000070u; // scancode_to_keycode(SC_F21)
const Keycode SDLK_F22                   =  0x40000071u; // scancode_to_keycode(SC_F22)
const Keycode SDLK_F23                   =  0x40000072u; // scancode_to_keycode(SC_F23)
const Keycode SDLK_F24                   =  0x40000073u; // scancode_to_keycode(SC_F24)
const Keycode SDLK_EXECUTE               =  0x40000074u; // scancode_to_keycode(SC_EXECUTE)
const Keycode SDLK_HELP                  =  0x40000075u; // scancode_to_keycode(SC_HELP)
const Keycode SDLK_MENU                  =  0x40000076u; // scancode_to_keycode(SC_MENU)
const Keycode SDLK_SELECT                =  0x40000077u; // scancode_to_keycode(SC_SELECT)
const Keycode SDLK_STOP                  =  0x40000078u; // scancode_to_keycode(SC_STOP)
const Keycode SDLK_AGAIN                 =  0x40000079u; // scancode_to_keycode(SC_AGAIN)
const Keycode SDLK_UNDO                  =  0x4000007au; // scancode_to_keycode(SC_UNDO)
const Keycode SDLK_CUT                   =  0x4000007bu; // scancode_to_keycode(SC_CUT)
const Keycode SDLK_COPY                  =  0x4000007cu; // scancode_to_keycode(SC_COPY)
const Keycode SDLK_PASTE                 =  0x4000007du; // scancode_to_keycode(SC_PASTE)
const Keycode SDLK_FIND                  =  0x4000007eu; // scancode_to_keycode(SC_FIND)
const Keycode SDLK_MUTE                  =  0x4000007fu; // scancode_to_keycode(SC_MUTE)
const Keycode SDLK_VOLUMEUP              =  0x40000080u; // scancode_to_keycode(SC_VOLUMEUP)
const Keycode SDLK_VOLUMEDOWN            =  0x40000081u; // scancode_to_keycode(SC_VOLUMEDOWN)
const Keycode SDLK_KP_COMMA              =  0x40000085u; // scancode_to_keycode(SC_KP_COMMA)
const Keycode SDLK_KP_EQUALSAS400        =  0x40000086u; // scancode_to_keycode(SC_KP_EQUALSAS400)
const Keycode SDLK_ALTERASE              =  0x40000099u; // scancode_to_keycode(SC_ALTERASE)
const Keycode SDLK_SYSREQ                =  0x4000009au; // scancode_to_keycode(SC_SYSREQ)
const Keycode SDLK_CANCEL                =  0x4000009bu; // scancode_to_keycode(SC_CANCEL)
const Keycode SDLK_CLEAR                 =  0x4000009cu; // scancode_to_keycode(SC_CLEAR)
const Keycode SDLK_PRIOR                 =  0x4000009du; // scancode_to_keycode(SC_PRIOR)
const Keycode SDLK_RETURN2               =  0x4000009eu; // scancode_to_keycode(SC_RETURN2)
const Keycode SDLK_SEPARATOR             =  0x4000009fu; // scancode_to_keycode(SC_SEPARATOR)
const Keycode SDLK_OUT                   =  0x400000a0u; // scancode_to_keycode(SC_OUT)
const Keycode SDLK_OPER                  =  0x400000a1u; // scancode_to_keycode(SC_OPER)
const Keycode SDLK_CLEARAGAIN            =  0x400000a2u; // scancode_to_keycode(SC_CLEARAGAIN)
const Keycode SDLK_CRSEL                 =  0x400000a3u; // scancode_to_keycode(SC_CRSEL)
const Keycode SDLK_EXSEL                 =  0x400000a4u; // scancode_to_keycode(SC_EXSEL)
const Keycode SDLK_KP_00                 =  0x400000b0u; // scancode_to_keycode(SC_KP_00)
const Keycode SDLK_KP_000                =  0x400000b1u; // scancode_to_keycode(SC_KP_000)
const Keycode SDLK_THOUSANDSSEPARATOR    =  0x400000b2u; // scancode_to_keycode(SC_THOUSANDSSEPARATOR)
const Keycode SDLK_DECIMALSEPARATOR      =  0x400000b3u; // scancode_to_keycode(SC_DECIMALSEPARATOR)
const Keycode SDLK_CURRENCYUNIT          =  0x400000b4u; // scancode_to_keycode(SC_CURRENCYUNIT)
const Keycode SDLK_CURRENCYSUBUNIT       =  0x400000b5u; // scancode_to_keycode(SC_CURRENCYSUBUNIT)
const Keycode SDLK_KP_LEFTPAREN          =  0x400000b6u; // scancode_to_keycode(SC_KP_LEFTPAREN)
const Keycode SDLK_KP_RIGHTPAREN         =  0x400000b7u; // scancode_to_keycode(SC_KP_RIGHTPAREN)
const Keycode SDLK_KP_LEFTBRACE          =  0x400000b8u; // scancode_to_keycode(SC_KP_LEFTBRACE)
const Keycode SDLK_KP_RIGHTBRACE         =  0x400000b9u; // scancode_to_keycode(SC_KP_RIGHTBRACE)
const Keycode SDLK_KP_TAB                =  0x400000bau; // scancode_to_keycode(SC_KP_TAB)
const Keycode SDLK_KP_BACKSPACE          =  0x400000bbu; // scancode_to_keycode(SC_KP_BACKSPACE)
const Keycode SDLK_KP_A                  =  0x400000bcu; // scancode_to_keycode(SC_KP_A)
const Keycode SDLK_KP_B                  =  0x400000bdu; // scancode_to_keycode(SC_KP_B)
const Keycode SDLK_KP_C                  =  0x400000beu; // scancode_to_keycode(SC_KP_C)
const Keycode SDLK_KP_D                  =  0x400000bfu; // scancode_to_keycode(SC_KP_D)
const Keycode SDLK_KP_E                  =  0x400000c0u; // scancode_to_keycode(SC_KP_E)
const Keycode SDLK_KP_F                  =  0x400000c1u; // scancode_to_keycode(SC_KP_F)
const Keycode SDLK_KP_XOR                =  0x400000c2u; // scancode_to_keycode(SC_KP_XOR)
const Keycode SDLK_KP_POWER              =  0x400000c3u; // scancode_to_keycode(SC_KP_POWER)
const Keycode SDLK_KP_PERCENT            =  0x400000c4u; // scancode_to_keycode(SC_KP_PERCENT)
const Keycode SDLK_KP_LESS               =  0x400000c5u; // scancode_to_keycode(SC_KP_LESS)
const Keycode SDLK_KP_GREATER            =  0x400000c6u; // scancode_to_keycode(SC_KP_GREATER)
const Keycode SDLK_KP_AMPERSAND          =  0x400000c7u; // scancode_to_keycode(SC_KP_AMPERSAND)
const Keycode SDLK_KP_DBLAMPERSAND       =  0x400000c8u; // scancode_to_keycode(SC_KP_DBLAMPERSAND)
const Keycode SDLK_KP_VERTICALBAR        =  0x400000c9u; // scancode_to_keycode(SC_KP_VERTICALBAR)
const Keycode SDLK_KP_DBLVERTICALBAR     =  0x400000cau; // scancode_to_keycode(SC_KP_DBLVERTICALBAR)
const Keycode SDLK_KP_COLON              =  0x400000cbu; // scancode_to_keycode(SC_KP_COLON)
const Keycode SDLK_KP_HASH               =  0x400000ccu; // scancode_to_keycode(SC_KP_HASH)
const Keycode SDLK_KP_SPACE              =  0x400000cdu; // scancode_to_keycode(SC_KP_SPACE)
const Keycode SDLK_KP_AT                 =  0x400000ceu; // scancode_to_keycode(SC_KP_AT)
const Keycode SDLK_KP_EXCLAM             =  0x400000cfu; // scancode_to_keycode(SC_KP_EXCLAM)
const Keycode SDLK_KP_MEMSTORE           =  0x400000d0u; // scancode_to_keycode(SC_KP_MEMSTORE)
const Keycode SDLK_KP_MEMRECALL          =  0x400000d1u; // scancode_to_keycode(SC_KP_MEMRECALL)
const Keycode SDLK_KP_MEMCLEAR           =  0x400000d2u; // scancode_to_keycode(SC_KP_MEMCLEAR)
const Keycode SDLK_KP_MEMADD             =  0x400000d3u; // scancode_to_keycode(SC_KP_MEMADD)
const Keycode SDLK_KP_MEMSUBTRACT        =  0x400000d4u; // scancode_to_keycode(SC_KP_MEMSUBTRACT)
const Keycode SDLK_KP_MEMMULTIPLY        =  0x400000d5u; // scancode_to_keycode(SC_KP_MEMMULTIPLY)
const Keycode SDLK_KP_MEMDIVIDE          =  0x400000d6u; // scancode_to_keycode(SC_KP_MEMDIVIDE)
const Keycode SDLK_KP_PLUSMINUS          =  0x400000d7u; // scancode_to_keycode(SC_KP_PLUSMINUS)
const Keycode SDLK_KP_CLEAR              =  0x400000d8u; // scancode_to_keycode(SC_KP_CLEAR)
const Keycode SDLK_KP_CLEARENTRY         =  0x400000d9u; // scancode_to_keycode(SC_KP_CLEARENTRY)
const Keycode SDLK_KP_BINARY             =  0x400000dau; // scancode_to_keycode(SC_KP_BINARY)
const Keycode SDLK_KP_OCTAL              =  0x400000dbu; // scancode_to_keycode(SC_KP_OCTAL)
const Keycode SDLK_KP_DECIMAL            =  0x400000dcu; // scancode_to_keycode(SC_KP_DECIMAL)
const Keycode SDLK_KP_HEXADECIMAL        =  0x400000ddu; // scancode_to_keycode(SC_KP_HEXADECIMAL)
const Keycode SDLK_LCTRL                 =  0x400000e0u; // scancode_to_keycode(SC_LCTRL)
const Keycode SDLK_LSHIFT                =  0x400000e1u; // scancode_to_keycode(SC_LSHIFT)
const Keycode SDLK_LALT                  =  0x400000e2u; // scancode_to_keycode(SC_LALT)
const Keycode SDLK_LGUI                  =  0x400000e3u; // scancode_to_keycode(SC_LGUI)
const Keycode SDLK_RCTRL                 =  0x400000e4u; // scancode_to_keycode(SC_RCTRL)
const Keycode SDLK_RSHIFT                =  0x400000e5u; // scancode_to_keycode(SC_RSHIFT)
const Keycode SDLK_RALT                  =  0x400000e6u; // scancode_to_keycode(SC_RALT)
const Keycode SDLK_RGUI                  =  0x400000e7u; // scancode_to_keycode(SC_RGUI)
const Keycode SDLK_MODE                  =  0x40000101u; // scancode_to_keycode(SC_MODE)
const Keycode SDLK_SLEEP                 =  0x40000102u; // scancode_to_keycode(SC_SLEEP)
const Keycode SDLK_WAKE                  =  0x40000103u; // scancode_to_keycode(SC_WAKE)
const Keycode SDLK_CHANNEL_INCREMENT     =  0x40000104u; // scancode_to_keycode(SC_CHANNEL_INCREMENT)
const Keycode SDLK_CHANNEL_DECREMENT     =  0x40000105u; // scancode_to_keycode(SC_CHANNEL_DECREMENT)
const Keycode SDLK_MEDIA_PLAY            =  0x40000106u; // scancode_to_keycode(SC_MEDIA_PLAY)
const Keycode SDLK_MEDIA_PAUSE           =  0x40000107u; // scancode_to_keycode(SC_MEDIA_PAUSE)
const Keycode SDLK_MEDIA_RECORD          =  0x40000108u; // scancode_to_keycode(SC_MEDIA_RECORD)
const Keycode SDLK_MEDIA_FAST_FORWARD    =  0x40000109u; // scancode_to_keycode(SC_MEDIA_FAST_FORWARD)
const Keycode SDLK_MEDIA_REWIND          =  0x4000010au; // scancode_to_keycode(SC_MEDIA_REWIND)
const Keycode SDLK_MEDIA_NEXT_TRACK      =  0x4000010bu; // scancode_to_keycode(SC_MEDIA_NEXT_TRACK)
const Keycode SDLK_MEDIA_PREVIOUS_TRACK  =  0x4000010cu; // scancode_to_keycode(SC_MEDIA_PREVIOUS_TRACK)
const Keycode SDLK_MEDIA_STOP            =  0x4000010du; // scancode_to_keycode(SC_MEDIA_STOP)
const Keycode SDLK_MEDIA_EJECT           =  0x4000010eu; // scancode_to_keycode(SC_MEDIA_EJECT)
const Keycode SDLK_MEDIA_PLAY_PAUSE      =  0x4000010fu; // scancode_to_keycode(SC_MEDIA_PLAY_PAUSE)
const Keycode SDLK_MEDIA_SELECT          =  0x40000110u; // scancode_to_keycode(SC_MEDIA_SELECT)
const Keycode SDLK_AC_NEW                =  0x40000111u; // scancode_to_keycode(SC_AC_NEW)
const Keycode SDLK_AC_OPEN               =  0x40000112u; // scancode_to_keycode(SC_AC_OPEN)
const Keycode SDLK_AC_CLOSE              =  0x40000113u; // scancode_to_keycode(SC_AC_CLOSE)
const Keycode SDLK_AC_EXIT               =  0x40000114u; // scancode_to_keycode(SC_AC_EXIT)
const Keycode SDLK_AC_SAVE               =  0x40000115u; // scancode_to_keycode(SC_AC_SAVE)
const Keycode SDLK_AC_PRINT              =  0x40000116u; // scancode_to_keycode(SC_AC_PRINT)
const Keycode SDLK_AC_PROPERTIES         =  0x40000117u; // scancode_to_keycode(SC_AC_PROPERTIES)
const Keycode SDLK_AC_SEARCH             =  0x40000118u; // scancode_to_keycode(SC_AC_SEARCH)
const Keycode SDLK_AC_HOME               =  0x40000119u; // scancode_to_keycode(SC_AC_HOME)
const Keycode SDLK_AC_BACK               =  0x4000011au; // scancode_to_keycode(SC_AC_BACK)
const Keycode SDLK_AC_FORWARD            =  0x4000011bu; // scancode_to_keycode(SC_AC_FORWARD)
const Keycode SDLK_AC_STOP               =  0x4000011cu; // scancode_to_keycode(SC_AC_STOP)
const Keycode SDLK_AC_REFRESH            =  0x4000011du; // scancode_to_keycode(SC_AC_REFRESH)
const Keycode SDLK_AC_BOOKMARKS          =  0x4000011eu; // scancode_to_keycode(SC_AC_BOOKMARKS)
const Keycode SDLK_SOFTLEFT              =  0x4000011fu; // scancode_to_keycode(SC_SOFTLEFT)
const Keycode SDLK_SOFTRIGHT             =  0x40000120u; // scancode_to_keycode(SC_SOFTRIGHT)
const Keycode SDLK_CALL                  =  0x40000121u; // scancode_to_keycode(SC_CALL)
const Keycode SDLK_ENDCALL               =  0x40000122u; // scancode_to_keycode(SC_ENDCALL)

module sdl3::keymod;

const Keymod NONE    =  0x0000u;
const Keymod LSHIFT  =  0x0001u;
const Keymod RSHIFT  =  0x0002u;
const Keymod LCTRL   =  0x0040u;
const Keymod RCTRL   =  0x0080u;
const Keymod LALT    =  0x0100u;
const Keymod RALT    =  0x0200u;
const Keymod LGUI    =  0x0400u;
const Keymod RGUI    =  0x0800u;
const Keymod NUM     =  0x1000u;
const Keymod CAPS    =  0x2000u;
const Keymod MODE    =  0x4000u;
const Keymod SCROLL  =  0x8000u;
const Keymod CTRL    =  (LCTRL | RCTRL);
const Keymod SHIFT   =  (LSHIFT | RSHIFT);
const Keymod ALT     =  (LALT | RALT);
const Keymod GUI     =  (LGUI | RGUI);

module sdl3;

fn FunctionPointer load_function(void* handle, ZString name) @extern("SDL_LoadFunction");
fn void* load_object(ZString sofile) @extern("SDL_LoadObject");
fn void unload_object(void* handle) @extern("SDL_UnloadObject");

module sdl3;

struct Locale
{
    ZString language;
    ZString country;
}

fn Locale** _get_preferred_locales(int* count) @extern("SDL_GetPreferredLocales") @local;

macro Locale[] get_preferred_locales()
{
    int count;
    Locale** _locales = _get_preferred_locales(&count);

    Locale[] locales = mem::new_array(Locale, count);
    for (int i = 0; i < count; ++i) locales[i] = (Locale)*_locales[i];
    return locales;
}

module sdl3;

def LogOutputFunction = fn void(void* userdata, int category, int priority, ZString message);

fn void log(ZString fmt, ...) @extern("SDL_Log");

fn void _log_critical(int category, ZString fmt, ...) @extern("SDL_LogCritical");
fn void _log_debug(int category, ZString fmt, ...) @extern("SDL_LogDebug");
fn void _log_error(int category, ZString fmt, ...) @extern("SDL_LogError");
fn void _log_info(int category, ZString fmt, ...) @extern("SDL_LogInfo");
fn void _log_verbose(int category, ZString fmt, ...) @extern("SDL_LogVerbose");
fn void _log_warn(int category, ZString fmt, ...) @extern("SDL_LogWarn");

fn void log_message(int category, int priority, ZString fmt, ...) @extern("SDL_LogMessage");
fn int get_log_priority(int category) @extern("SDL_GetLogPriority");
fn void reset_log_priorities() @extern("SDL_ResetLogPriorities");
fn void get_log_output_function(LogOutputFunction* callback, void** userdata) @extern("SDL_GetLogOutputFunction");
fn void set_log_output_function(LogOutputFunction callback, void* userdata) @extern("SDL_SetLogOutputFunction");

macro void log_critical(ZString fmt, ..., CInt prio = log_priority::CRITICAL)
{
    _log_critical(prio, fmt, $vasplat);
}

macro void log_debug(ZString fmt, ..., CInt prio = log_priority::DEBUG)
{
    _log_debug(prio, fmt, $vasplat);
}

macro void log_error(ZString fmt, ..., CInt prio = log_priority::ERROR)
{
    _log_error(prio, fmt, $vasplat);
}

macro void log_info(ZString fmt, ..., CInt prio = log_priority::INFO)
{
    _log_info(prio, fmt, $vasplat);
}

macro void log_verbose(ZString fmt, ..., CInt prio = log_priority::VERBOSE)
{
    _log_verbose(prio, fmt, $vasplat);
}

macro void log_warn(ZString fmt, ..., CInt prio = log_priority::WARN)
{
    _log_warn(prio, fmt, $vasplat);
}

module sdl3::log_priority;

const int VERBOSE = 1;
const int DEBUG = 2;
const int INFO = 3;
const int WARN = 4;
const int ERROR = 5;
const int CRITICAL = 6;
const int NUM_PRIORITIES = 7;

module sdl3::log_category;

const int APPLICATION = 0;
const int ERROR = 1;
const int ASSERT = 2;
const int SYSTEM = 3;
const int AUDIO = 4;
const int VIDEO = 5;
const int RENDER = 6;
const int INPUT = 7;
const int TEST = 8;
const int RESERVED1 = 9;
const int RESERVED2 = 10;
const int RESERVED3 = 11;
const int RESERVED4 = 12;
const int RESERVED5 = 13;
const int RESERVED6 = 14;
const int RESERVED7 = 15;
const int RESERVED8 = 16;
const int RESERVED9 = 17;
const int RESERVED10 = 18;
const int CUSTOM = 19;

module sdl3;

def MessageBoxColorType = uint;

distinct MessageBoxButtonFlags = uint;
distinct MessageBoxFlags = uint;

struct MessageBoxButtonData
{
    MessageBoxButtonFlags flags;
    int buttonID;
    ZString text;
}

struct MessageBoxColor
{
    char r, g, b;
}

struct MessageBoxColorScheme
{
    MessageBoxColor[message_box_color_type::MAX] colors;
}

struct MessageBoxData
{
    MessageBoxFlags flags;
    Window* window;
    ZString title;
    ZString message;

    int numbuttons;
    MessageBoxButtonData* buttons;

    MessageBoxColorScheme* colorScheme;
}

fn int show_message_box(MessageBoxData* messageboxdata, int* buttonid) @extern("SDL_ShowMessageBox");
fn int show_simple_message_box(MessageBoxFlags flags, ZString title, ZString message, Window* window) @extern("SDL_ShowSimpleMessageBox");

module sdl3::message_box_button_flags;

const MessageBoxButtonFlags RETURNKEY_DEFAULT  =  0x00000001u;
const MessageBoxButtonFlags ESCAPEKEY_DEFAULT  =  0x00000002u;

module sdl3::message_box_flags;

const MessageBoxFlags ERROR                  =  0x00000010u;
const MessageBoxFlags WARNING                =  0x00000020u;
const MessageBoxFlags INFORMATION            =  0x00000040u;
const MessageBoxFlags BUTTONS_LEFT_TO_RIGHT  =  0x00000080u;
const MessageBoxFlags BUTTONS_RIGHT_TO_LEFT  =  0x00000100u;

module sdl3::message_box_color_type;

const MessageBoxColorType BACKGROUND         =  0;
const MessageBoxColorType TEXT               =  1;
const MessageBoxColorType BUTTON_BORDER      =  2;
const MessageBoxColorType BUTTON_BACKGROUND  =  3;
const MessageBoxColorType BUTTON_SELECTED    =  4;
const MessageBoxColorType MAX                =  5;

module sdl3;

distinct MetalView = void*;

fn MetalView metal_create_view(Window* window) @extern("SDL_Metal_CreateView");
fn void metal_destroy_view(MetalView view) @extern("SDL_Metal_DestroyView");
fn void* metal_get_layer(MetalView view) @extern("SDL_Metal_GetLayer");

module sdl3;

fn int open_url(ZString url) @extern("SDL_OpenURL");

module sdl3;

distinct Cursor = void*;
distinct MouseButtonFlags = uint;
distinct MouseID = uint;
distinct MouseWheelDirection = uint;
distinct SystemCursor = uint;

fn int capture_mouse(bool enabled) @extern("SDL_CaptureMouse");
fn Cursor* create_color_cursor(Surface* surface, int hot_x, int hot_y) @extern("SDL_CreateColorCursor");
fn Cursor* create_cursor(ZString data, ZString mask, int w, int h, int hot_x, int hot_y) @extern("SDL_CreateCursor");
fn Cursor* create_system_cursor(SystemCursor id) @extern("SDL_CreateSystemCursor");
fn bool cursor_visible() @extern("SDL_CursorVisible");
fn void destroy_cursor(Cursor* cursor) @extern("SDL_DestroyCursor");
fn Cursor* get_cursor() @extern("SDL_GetCursor");
fn Cursor* get_default_cursor() @extern("SDL_GetDefaultCursor");
fn MouseButtonFlags get_global_mouse_state(float* x, float* y) @extern("SDL_GetGlobalMouseState");
fn MouseID* get_mice(int* count) @extern("SDL_GetMice");
fn Window* get_mouse_focus() @extern("SDL_GetMouseFocus");
fn ZString get_mouse_name_for_id(MouseID instance_id) @extern("SDL_GetMouseNameForID");
fn MouseButtonFlags get_mouse_state(float* x, float* y) @extern("SDL_GetMouseState");
fn MouseButtonFlags get_relative_mouse_state(float* x, float* y) @extern("SDL_GetRelativeMouseState");
fn bool get_window_relative_mouse_mode(Window* window) @extern("SDL_GetWindowRelativeMouseMode");
fn bool has_mouse() @extern("SDL_HasMouse");
fn int hide_cursor() @extern("SDL_HideCursor");
fn int set_cursor(Cursor* cursor) @extern("SDL_SetCursor");
fn int set_window_relative_mouse_mode(Window* window, bool enbaled) @extern("SDL_SetWindowRelativeMouseMode");
fn int show_cursor() @extern("SDL_ShowCursor");
fn int warp_mouse_global(float x, float y) @extern("SDL_WarpMouseGlobal");
fn void warp_mouse_in_window(Window* window, float x, float y) @extern("SDL_WarpMouseInWindow");

module sdl3::mouse_button_flags;

macro @mouse_button_mask($x) @local => (MouseButtonFlags)(1u << ((uint)$x-1));

const MouseButtonFlags LEFT     =  0x1;
const MouseButtonFlags MIDDLE   =  0x2;
const MouseButtonFlags RIGHT    =  0x3;
const MouseButtonFlags X1       =  0x4;
const MouseButtonFlags X2       =  0x5;
const MouseButtonFlags LMASK    =  @mouse_button_mask(LEFT);
const MouseButtonFlags MMASK    =  @mouse_button_mask(MIDDLE);
const MouseButtonFlags RMASK    =  @mouse_button_mask(RIGHT);
const MouseButtonFlags X1MASK   =  @mouse_button_mask(X1);
const MouseButtonFlags X2MASK   =  @mouse_button_mask(X2);

module sdl3::mouse_wheel_direction;

const MouseWheelDirection NORMAL   =  0x0;
const MouseWheelDirection FLIPPED  =  0x1;

module sdl3::system_cursor;

const SystemCursor DEFAULT      =   0x0;
const SystemCursor TEXT         =   0x1;
const SystemCursor WAIT         =   0x2;
const SystemCursor CROSSHAIR    =   0x3;
const SystemCursor PROGRESS     =   0x4;
const SystemCursor NWSE_RESIZE  =   0x5;
const SystemCursor NESW_RESIZE  =   0x6;
const SystemCursor EW_RESIZE    =   0x7;
const SystemCursor NS_RESIZE    =   0x8;
const SystemCursor MOVE         =   0x9;
const SystemCursor NOT_ALLOWED  =   0xa;
const SystemCursor POINTER      =   0xb;
const SystemCursor NW_RESIZE    =   0xc;
const SystemCursor N_RESIZE     =   0xd;
const SystemCursor NE_RESIZE    =   0xe;
const SystemCursor E_RESIZE     =   0xf;
const SystemCursor SE_RESIZE    =  0x10;
const SystemCursor S_RESIZE     =  0x11;
const SystemCursor SW_RESIZE    =  0x12;
const SystemCursor W_RESIZE     =  0x13;

module sdl3;

const uint MUTEX_TIMEDOUT  =  1;

distinct Condition = void*;
distinct Mutex = void*;
distinct RWLock = void*;
distinct Semaphore = void*;

fn int broadcast_condition(Condition* cond) @extern("SDL_BroadcastCondition");
fn Condition* create_condition() @extern("SDL_CreateCondition");
fn Mutex* create_mutex() @extern("SDL_CreateMutex");
fn RWLock* create_rw_lock() @extern("SDL_CreateRWLock");
fn Semaphore* create_semaphore(uint initial_value) @extern("SDL_CreateSemaphore");
fn void destroy_condition(Condition* cond) @extern("SDL_DestroyCondition");
fn void destroy_mutex(Mutex* mutex) @extern("SDL_DestroyMutex");
fn void destroy_rw_lock(RWLock* rwlock) @extern("SDL_DestroyRWLock");
fn void destroy_semaphore(Semaphore* sem) @extern("SDL_DestroySemaphore");
fn uint get_semaphore_value(Semaphore* sem) @extern("SDL_GetSemaphoreValue");
fn void lock_mutex(Mutex* mutex) @extern("SDL_LockMutex");
fn void lock_rw_lock_for_reading(RWLock* rwlock) @extern("SDL_LockRWLockForReading");
fn void lock_rw_lock_for_writing(RWLock* rwlock) @extern("SDL_LockRWLockForWriting");
fn int signal_condition(Condition* cond) @extern("SDL_SignalCondition");
fn int signal_semaphore(Semaphore* sem) @extern("SDL_SignalSemaphore");
fn int try_lock_mutex(Mutex* mutex) @extern("SDL_TryLockMutex");
fn int try_lock_rw_lock_for_reading(RWLock* rwlock) @extern("SDL_TryLockRWLockForReading");
fn int try_lock_rw_lock_for_writing(RWLock* rwlock) @extern("SDL_TryLockRWLockForWriting");
fn int try_wait_semaphore(Semaphore* sem) @extern("SDL_TryWaitSemaphore");
fn void unlock_mutex(Mutex* mutex) @extern("SDL_UnlockMutex");
fn void unlock_rw_lock(RWLock* rwlock) @extern("SDL_UnlockRWLock");
fn int wait_condition(Condition* cond, Mutex* mutex) @extern("SDL_WaitCondition");
fn int wait_condition_timeout(Condition* cond, Mutex* mutex, int timeoutMS) @extern("SDL_WaitConditionTimeout");
fn int wait_semaphore(Semaphore* sem) @extern("SDL_WaitSemaphore");
fn int wait_semaphore_timeout(Semaphore* sem, int timeoutMS) @extern("SDL_WaitSemaphoreTimeout");

module sdl3;

distinct PenAxis = uint;
distinct PenID = uint;
distinct PenInputFlags = uint;

module sdl3::pen_axis;

const PenAxis PRESSURE             =  0x0;
const PenAxis XTILT                =  0x1;
const PenAxis YTILT                =  0x2;
const PenAxis DISTANCE             =  0x3;
const PenAxis ROTATION             =  0x4;
const PenAxis SLIDER               =  0x5;
const PenAxis TANGENTIAL_PRESSURE  =  0x6;
const PenAxis NUM_AXES             =  0x7;

module sdl3::pen_input_flags;

const PenInputFlags DOWN       = (1u << 0);
const PenInputFlags BUTTON_1   = (1u << 1);
const PenInputFlags BUTTON_2   = (1u << 2);
const PenInputFlags BUTTON_3   = (1u << 3);
const PenInputFlags BUTTON_4   = (1u << 4);
const PenInputFlags BUTTON_5   = (1u << 5);
const PenInputFlags ERASER_TIP = (1u << 30);

module sdl3;

distinct ChromaLocation = uint;
distinct ColorPrimaries = uint;
distinct ColorRange = uint;
distinct Colorspace = uint;
distinct ColorType = uint;
distinct MatrixCoefficients = uint;
distinct PixelFormat = uint;
distinct TransferCharacteristics = uint;

struct Color
{
    char r, g, b, a;
}

struct FColor
{
    float r, g, b, a;
}

struct Palette
{
    int ncolors;
    Color* colors;
    uint version;
    int refcount;
}

struct PixelFormatDetails
{
    PixelFormat format;
    char bits_per_pixel;
    char bytes_per_pixel;
    char[2] padding;
    uint r_mask;
    uint g_mask;
    uint b_mask;
    uint a_mask;
    char r_bits;
    char g_bits;
    char b_bits;
    char a_bits;
    char r_shift;
    char g_shift;
    char b_shift;
    char a_shift;
}

fn Palette* create_palette(int ncolors) @extern("SDL_CreatePalette");
fn void destroy_palette(Palette* palette) @extern("SDL_DestroyPalette");
fn int get_masks_for_pixel_format(PixelFormat format, int* bpp, uint* r_mask, uint* g_mask, uint* b_mask, uint* a_mask) @extern("SDL_GetMasksForPixelFormat");
fn PixelFormatDetails* get_pixel_format_details(PixelFormat format) @extern("SDL_GetPixelFormatDetails");
fn PixelFormat get_pixel_format_for_masks(int bpp, uint r_mask, uint g_mask, uint b_mask, uint a_mask) @extern("SDL_GetPixelFormatForMasks");
fn ZString get_pixel_format_name(PixelFormat format) @extern("SDL_GetPixelFormatName");
fn void get_rgb(uint pixel, PixelFormatDetails* format, Palette* palette, ZString r, ZString g, ZString b) @extern("SDL_GetRGB");
fn void get_rgba(uint pixel, PixelFormatDetails* format, Palette* palette, ZString r, ZString g, ZString b, ZString a) @extern("SDL_GetRGBA");
fn uint map_rgb(PixelFormatDetails* format, Palette* palette, char r, char g, char b) @extern("SDL_MapRGB");
fn uint map_rgba(PixelFormatDetails* format, Palette* palette, char r, char g, char b, char a) @extern("SDL_MapRGBA");
fn int set_palette_colors(Palette* palette, Color* colors, int firstcolor, int ncolors) @extern("SDL_SetPaletteColors");

module sdl3::chroma_location;

const ChromaLocation SDL_CHROMA_LOCATION_NONE     =  0;
const ChromaLocation SDL_CHROMA_LOCATION_LEFT     =  1;
const ChromaLocation SDL_CHROMA_LOCATION_CENTER   =  2;
const ChromaLocation SDL_CHROMA_LOCATION_TOPLEFT  =  3;

module sdl3::color_primaries;

const ColorPrimaries UNKNOWN       =  0;
const ColorPrimaries BT709         =  1;
const ColorPrimaries UNSPECIFIED   =  2;
const ColorPrimaries BT470M        =  4;
const ColorPrimaries BT470BG       =  5;
const ColorPrimaries BT601         =  6;
const ColorPrimaries SMPTE240      =  7;
const ColorPrimaries GENERIC_FILM  =  8;
const ColorPrimaries BT2020        =  9;
const ColorPrimaries XYZ           =  10;
const ColorPrimaries SMPTE431      =  11;
const ColorPrimaries SMPTE432      =  12;
const ColorPrimaries EBU3213       =  22;
const ColorPrimaries CUSTOM        =  31;

module sdl3::color_range;

const ColorRange UNKNOWN  =  0;
const ColorRange LIMITED  =  1;
const ColorRange FULL     =  2;

module sdl3::color_space;

const Colorspace UNKNOWN         =  0;
const Colorspace SRGB            =  0x120005a0u;
const Colorspace SRGB_LINEAR     =  0x12000500u;
const Colorspace JPEG            =  0x220004c6u;
const Colorspace BT601_LIMITED   =  0x211018c6u;
const Colorspace BT601_FULL      =  0x221018c6u;
const Colorspace BT709_LIMITED   =  0x21100421u;
const Colorspace BT709_FULL      =  0x22100421u;
const Colorspace BT2020_LIMITED  =  0x21102609u;
const Colorspace BT2020_FULL     =  0x22102609u;

module sdl3::color_type;

const ColorType UNKNOWN  =  0;
const ColorType RGB      =  1;
const ColorType YCBCR    =  2;

module sdl3::matrix_coefficients;

const MatrixCoefficients IDENTITY            =  0;
const MatrixCoefficients BT709               =  1;
const MatrixCoefficients UNSPECIFIED         =  2;
const MatrixCoefficients FCC                 =  4;
const MatrixCoefficients BT470BG             =  5;
const MatrixCoefficients BT601               =  6;
const MatrixCoefficients SMPTE240            =  7;
const MatrixCoefficients YCGCO               =  8;
const MatrixCoefficients BT2020_NCL          =  9;
const MatrixCoefficients BT2020_CL           =  10;
const MatrixCoefficients SMPTE2085           =  11;
const MatrixCoefficients CHROMA_DERIVED_NCL  =  12;
const MatrixCoefficients CHROMA_DERIVED_CL   =  13;
const MatrixCoefficients ICTCP               =  14;
const MatrixCoefficients CUSTOM              =  31;

module sdl3::pixel_format;

const PixelFormat UNKNOWN        =  0;
const PixelFormat INDEX1MSB      =  0x11200100u;
const PixelFormat INDEX2LSB      =  0x1c100200u;
const PixelFormat INDEX2MSB      =  0x1c200200u;
const PixelFormat INDEX4LSB      =  0x12100400u;
const PixelFormat INDEX4MSB      =  0x12200400u;
const PixelFormat INDEX8         =  0x13000801u;
const PixelFormat RGB332         =  0x14110801u;
const PixelFormat XRGB4444       =  0x15120c02u;
const PixelFormat XBGR4444       =  0x15520c02u;
const PixelFormat XRGB1555       =  0x15130f02u;
const PixelFormat XBGR1555       =  0x15530f02u;
const PixelFormat ARGB4444       =  0x15321002u;
const PixelFormat RGBA4444       =  0x15421002u;
const PixelFormat ABGR4444       =  0x15721002u;
const PixelFormat BGRA4444       =  0x15821002u;
const PixelFormat ARGB1555       =  0x15331002u;
const PixelFormat RGBA5551       =  0x15441002u;
const PixelFormat ABGR1555       =  0x15731002u;
const PixelFormat BGRA5551       =  0x15841002u;
const PixelFormat RGB565         =  0x15151002u;
const PixelFormat BGR565         =  0x15551002u;
const PixelFormat RGB24          =  0x17101803u;
const PixelFormat BGR24          =  0x17401803u;
const PixelFormat XRGB8888       =  0x16161804u;
const PixelFormat RGBX8888       =  0x16261804u;
const PixelFormat XBGR8888       =  0x16561804u;
const PixelFormat BGRX8888       =  0x16661804u;
const PixelFormat ARGB8888       =  0x16362004u;
const PixelFormat RGBA8888       =  0x16462004u;
const PixelFormat ABGR8888       =  0x16762004u;
const PixelFormat BGRA8888       =  0x16862004u;
const PixelFormat XRGB2101010    =  0x16172004u;
const PixelFormat XBGR2101010    =  0x16572004u;
const PixelFormat ARGB2101010    =  0x16372004u;
const PixelFormat ABGR2101010    =  0x16772004u;
const PixelFormat RGB48          =  0x18103006u;
const PixelFormat BGR48          =  0x18403006u;
const PixelFormat RGBA64         =  0x18204008u;
const PixelFormat ARGB64         =  0x18304008u;
const PixelFormat BGRA64         =  0x18504008u;
const PixelFormat ABGR64         =  0x18604008u;
const PixelFormat RGB48_FLOAT    =  0x1a103006u;
const PixelFormat BGR48_FLOAT    =  0x1a403006u;
const PixelFormat RGBA64_FLOAT   =  0x1a204008u;
const PixelFormat ARGB64_FLOAT   =  0x1a304008u;
const PixelFormat BGRA64_FLOAT   =  0x1a504008u;
const PixelFormat ABGR64_FLOAT   =  0x1a604008u;
const PixelFormat RGB96_FLOAT    =  0x1b10600cu;
const PixelFormat BGR96_FLOAT    =  0x1b40600cu;
const PixelFormat RGBA128_FLOAT  =  0x1b208010u;
const PixelFormat ARGB128_FLOAT  =  0x1b308010u;
const PixelFormat BGRA128_FLOAT  =  0x1b508010u;
const PixelFormat ABGR128_FLOAT  =  0x1b608010u;
const PixelFormat YV12           =  0x32315659u;
const PixelFormat IYUV           =  0x56555949u;
const PixelFormat YUY2           =  0x32595559u;
const PixelFormat UYVY           =  0x59565955u;
const PixelFormat YVYU           =  0x55595659u;
const PixelFormat NV12           =  0x3231564eu;
const PixelFormat NV21           =  0x3132564eu;
const PixelFormat P010           =  0x30313050u;
const PixelFormat EXTERNAL_OES   =  0x2053454fu;

module sdl3::transfer_characteristics;

const TransferCharacteristics UNKNOWN        =  0;
const TransferCharacteristics BT709          =  1;
const TransferCharacteristics UNSPECIFIED    =  2;
const TransferCharacteristics GAMMA22        =  4;
const TransferCharacteristics GAMMA28        =  5;
const TransferCharacteristics BT601          =  6;
const TransferCharacteristics SMPTE240       =  7;
const TransferCharacteristics LINEAR         =  8;
const TransferCharacteristics LOG100         =  9;
const TransferCharacteristics LOG100_SQRT10  =  10;
const TransferCharacteristics IEC61966       =  11;
const TransferCharacteristics BT1361         =  12;
const TransferCharacteristics SRGB           =  13;
const TransferCharacteristics BT2020_10BIT   =  14;
const TransferCharacteristics BT2020_12BIT   =  15;
const TransferCharacteristics PQ             =  16;
const TransferCharacteristics SMPTE428       =  17;
const TransferCharacteristics HLG            =  18;
const TransferCharacteristics CUSTOM         =  31;

module sdl3;

fn ZString get_platform() @extern("SDL_GetPlatform");

module sdl3;

distinct PowerState = int;

fn PowerState get_power_info(int* seconds, int* percent) @extern("SDL_GetPowerInfo");

module sdl3;

distinct PropertiesID = uint;
distinct PropertyType = uint;

module sdl3::property_type;

const PropertyType INVALID  =  0;
const PropertyType POINTER  =  1;
const PropertyType STRING   =  2;
const PropertyType NUMBER   =  3;
const PropertyType FLOAT    =  4;
const PropertyType BOOLEAN  =  5;

module sdl3;

struct Point
{
    int x, y;
}

struct FPoint
{
    float x, y;
}

struct Rect
{
    int x, y;
    int w, h;
}

struct FRect
{
    float x, y;
    float w, h;
}

fn bool get_rect_and_line_intersection(Rect * rect, int* x1, int* y1, int* x2, int* y2) @extern("SDL_GetRectAndLineIntersection");
fn bool get_rect_and_line_intersection_float(FRect * rect, float* x1, float* y1, float* x2, float* y2) @extern("SDL_GetRectAndLineIntersectionFloat");
fn bool get_rect_enclosing_points(Point * points, int count, Rect * clip, Rect * result) @extern("SDL_GetRectEnclosingPoints");
fn bool get_rect_enclosing_points_float(FPoint * points, int count, FRect * clip, FRect * result) @extern("SDL_GetRectEnclosingPointsFloat");
fn bool get_rect_intersection(Rect * a, Rect * b, Rect * result) @extern("SDL_GetRectIntersection");
fn bool get_rect_intersection_float(FRect * a, FRect * b, FRect * result) @extern("SDL_GetRectIntersectionFloat");
fn bool get_rect_union(Rect * a, Rect * b, Rect * result) @extern("SDL_GetRectUnion");
fn bool get_rect_union_float(FRect * a, FRect * b, FRect * result) @extern("SDL_GetRectUnionFloat");
fn bool has_rect_intersection(Rect * a, Rect * b) @extern("SDL_HasRectIntersection");
fn bool has_rect_intersection_float(FRect * a, FRect * b) @extern("SDL_HasRectIntersectionFloat");
fn bool point_in_rect(Point* p, Rect* r) @extern("SDL_PointInRect");
fn bool point_in_rect_float(FPoint* p, FRect* r) @extern("SDL_PointInRectFloat");

module sdl3;

distinct Renderer = void*;
distinct Texture  = void*;

struct Vertex
{
    FPoint position;
    FColor color;
    FPoint tex_coord;
}

fn Renderer* create_renderer(Window* window, ZString name) @extern("SDL_CreateRenderer");
fn Renderer* create_renderer_with_properties(PropertiesID props) @extern("SDL_CreateRendererWithProperties");
fn Renderer* create_software_renderer(Surface* surface) @extern("SDL_CreateSoftwareRenderer");
// fn int create_window_and_renderer(ZString title, int width, int height, WindowFlags window_flags, Window** window, Renderer** renderer) @extern("SDL_CreateWindowAndRenderer");
fn void destroy_renderer(Renderer* renderer) @extern("SDL_DestroyRenderer");

fn int flush_renderer(Renderer* renderer) @extern("SDL_FlushRenderer");
fn int get_current_render_output_size(Renderer* renderer, int* w, int* h) @extern("SDL_GetCurrentRenderOutputSize");
fn int get_num_render_drivers() @extern("SDL_GetNumRenderDrivers");
fn int get_render_clip_rect(Renderer* renderer, Rect* rect) @extern("SDL_GetRenderClipRect");
fn int get_render_color_scale(Renderer* renderer, float* scale) @extern("SDL_GetRenderColorScale");
fn int get_render_draw_blend_mode(Renderer* renderer, BlendMode* blendMode) @extern("SDL_GetRenderDrawBlendMode");

fn int render_clear(Renderer* renderer) @extern("SDL_RenderClear");
fn int render_present(Renderer* renderer) @extern("SDL_RenderPresent");
fn bool render_clip_enabled(Renderer* renderer) @extern("SDL_RenderClipEnabled");
fn int render_coordinates_from_window(Renderer* renderer, float window_x, float window_y, float* x, float* y) @extern("SDL_RenderCoordinatesFromWindow");
fn int render_coordinates_to_window(Renderer* renderer, float x, float y, float* window_x, float* window_y) @extern("SDL_RenderCoordinatesToWindow");
fn int render_fill_rect(Renderer* renderer, FRect* rect) @extern("SDL_RenderFillRect");
fn int render_fill_rects(Renderer* renderer, FRect* rects, int count) @extern("SDL_RenderFillRects");
fn int render_geometry(Renderer* renderer, Texture* texture, Vertex* vertices, int num_vertices, int* indices, int num_indices) @extern("SDL_RenderGeometry");
fn int render_geometry_raw(Renderer* renderer, Texture* texture, float* xy, int xy_stride, FColor* color, int color_stride, float* uv, int uv_stride, int num_vertices, void* indices, int num_indices, int size_indices) @extern("SDL_RenderGeometryRaw");
fn int render_line(Renderer* renderer, float x1, float y1, float x2, float y2) @extern("SDL_RenderLine");
fn int render_lines(Renderer* renderer, FPoint* points, int count) @extern("SDL_RenderLines");
fn int render_point(Renderer* renderer, float x, float y) @extern("SDL_RenderPoint");
fn int render_points(Renderer* renderer, FPoint* points, int count) @extern("SDL_RenderPoints");
fn Surface* render_read_pixels(Renderer* renderer, Rect* rect) @extern("SDL_RenderReadPixels");
fn int render_rect(Renderer* renderer, FRect* rect) @extern("SDL_RenderRect");
fn int render_rects(Renderer* renderer, FRect* rects, int count) @extern("SDL_RenderRects");
fn int render_texture(Renderer* renderer, Texture* texture, FRect* srcrect, FRect* dstrect) @extern("SDL_RenderTexture");
fn int render_texture9_grid(Renderer* renderer, Texture* texture, FRect* srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, FRect* dstrect) @extern("SDL_RenderTexture9Grid");
fn int render_texture_rotated(Renderer* renderer, Texture* texture, FRect* srcrect, FRect* dstrect, double angle, FPoint* center, FlipMode flip) @extern("SDL_RenderTextureRotated");
fn int render_texture_tiled(Renderer* renderer, Texture* texture, FRect* srcrect, float scale, FRect* dstrect) @extern("SDL_RenderTextureTiled");
fn bool render_viewport_set(Renderer* renderer) @extern("SDL_RenderViewportSet");
fn ZString get_render_driver(int index) @extern("SDL_GetRenderDriver");
fn Renderer* get_renderer(Window* window) @extern("SDL_GetRenderer");
fn Renderer* get_renderer_from_texture(Texture* texture) @extern("SDL_GetRendererFromTexture");
fn ZString get_renderer_name(Renderer* renderer) @extern("SDL_GetRendererName");
fn PropertiesID get_renderer_properties(Renderer* renderer) @extern("SDL_GetRendererProperties");
fn int get_render_logical_presentation(Renderer* renderer, int* w, int* h, RendererLogicalPresentation* mode, ScaleMode* scale_mode) @extern("SDL_GetRenderLogicalPresentation");
fn int get_render_logical_presentation_rect(Renderer* renderer, FRect* rect) @extern("SDL_GetRenderLogicalPresentationRect");
fn void* get_render_metal_command_encoder(Renderer* renderer) @extern("SDL_GetRenderMetalCommandEncoder");
fn void* get_render_metal_layer(Renderer* renderer) @extern("SDL_GetRenderMetalLayer");
fn int get_render_output_size(Renderer* renderer, int* w, int* h) @extern("SDL_GetRenderOutputSize");
fn int get_render_safe_area(Renderer* renderer, Rect* rect) @extern("SDL_GetRenderSafeArea");
fn int get_render_scale(Renderer* renderer, float* scaleX, float* scaleY) @extern("SDL_GetRenderScale");
fn Texture* get_render_target(Renderer* renderer) @extern("SDL_GetRenderTarget");
fn int get_render_viewport(Renderer* renderer, Rect* rect) @extern("SDL_GetRenderViewport");
fn int get_render_v_sync(Renderer* renderer, int* vsync) @extern("SDL_GetRenderVSync");
fn Window* get_render_window(Renderer* renderer) @extern("SDL_GetRenderWindow");
fn int set_render_draw_color(Renderer* renderer, char r, char g, char b, char a) @extern("SDL_SetRenderDrawColor");
fn int set_render_draw_color_float(Renderer* renderer, float r, float g, float b, float a) @extern("SDL_SetRenderDrawColorFloat");
fn int set_render_clip_rect(Renderer* renderer, Rect* rect) @extern("SDL_SetRenderClipRect");
fn int set_render_color_scale(Renderer* renderer, float scale) @extern("SDL_SetRenderColorScale");
fn int set_render_draw_blend_mode(Renderer* renderer, BlendMode blendMode) @extern("SDL_SetRenderDrawBlendMode");
fn int set_render_logical_presentation(Renderer* renderer, int w, int h, RendererLogicalPresentation mode, ScaleMode scale_mode) @extern("SDL_SetRenderLogicalPresentation");
fn int set_render_scale(Renderer* renderer, float scaleX, float scaleY) @extern("SDL_SetRenderScale");
fn int set_render_target(Renderer* renderer, Texture* texture) @extern("SDL_SetRenderTarget");
fn int set_render_viewport(Renderer* renderer, Rect* rect) @extern("SDL_SetRenderViewport");
fn int set_render_v_sync(Renderer* renderer, int vsync) @extern("SDL_SetRenderVSync");

fn Texture* create_texture(Renderer* renderer, PixelFormat format, TextureAccess access, int w, int h) @extern("SDL_CreateTexture");
fn Texture* create_texture_from_surface(Renderer* renderer, Surface* surface) @extern("SDL_CreateTextureFromSurface");
fn Texture* create_texture_with_properties(Renderer* renderer, PropertiesID props) @extern("SDL_CreateTextureWithProperties");
fn int get_texture_alpha_mod(Texture* texture, ZString alpha) @extern("SDL_GetTextureAlphaMod");
fn int get_texture_alpha_mod_float(Texture* texture, float* alpha) @extern("SDL_GetTextureAlphaModFloat");
fn int get_texture_blend_mode(Texture* texture, BlendMode* blendMode) @extern("SDL_GetTextureBlendMode");
fn int get_texture_color_mod(Texture* texture, ZString r, ZString g, ZString b) @extern("SDL_GetTextureColorMod");
fn int get_texture_color_mod_float(Texture* texture, float* r, float* g, float* b) @extern("SDL_GetTextureColorModFloat");
fn PropertiesID get_texture_properties(Texture* texture) @extern("SDL_GetTextureProperties");
fn int get_texture_scale_mode(Texture* texture, ScaleMode* scaleMode) @extern("SDL_GetTextureScaleMode");
fn int get_texture_size(Texture* texture, float* w, float* h) @extern("SDL_GetTextureSize");
fn int lock_texture(Texture* texture, Rect* rect, void** pixels, int* pitch) @extern("SDL_LockTexture");
fn int lock_texture_to_surface(Texture* texture, Rect* rect, Surface** surface) @extern("SDL_LockTextureToSurface");
fn int set_texture_alpha_mod(Texture* texture, char alpha) @extern("SDL_SetTextureAlphaMod");
fn int set_texture_alpha_mod_float(Texture* texture, float alpha) @extern("SDL_SetTextureAlphaModFloat");
fn int set_texture_blend_mode(Texture* texture, BlendMode blendMode) @extern("SDL_SetTextureBlendMode");
fn int set_texture_color_mod(Texture* texture, char r, char g, char b) @extern("SDL_SetTextureColorMod");
fn int set_texture_color_mod_float(Texture* texture, float r, float g, float b) @extern("SDL_SetTextureColorModFloat");
fn int set_texture_scale_mode(Texture* texture, ScaleMode scaleMode) @extern("SDL_SetTextureScaleMode");
fn void unlock_texture(Texture* texture) @extern("SDL_UnlockTexture");
fn int update_nv_texture(Texture* texture, Rect* rect, ZString yplane, int ypitch, ZString uvplane, int uvpitch) @extern("SDL_UpdateNVTexture");
fn int update_texture(Texture* texture, Rect* rect, void* pixels, int pitch) @extern("SDL_UpdateTexture");
fn int update_yuv_texture(Texture* texture, Rect* rect, ZString yplane, int ypitch, ZString uplane, int upitch, ZString vplane, int vpitch) @extern("SDL_UpdateYUVTexture");
fn void destroy_texture(Texture* texture) @extern("SDL_DestroyTexture");

fn int add_vulkan_render_semaphores(Renderer* renderer, uint wait_stage_mask, long wait_semaphore, long signal_semaphore) @extern("SDL_AddVulkanRenderSemaphores");
fn int convert_event_to_render_coordinates(Renderer* renderer, Event* event) @extern("SDL_ConvertEventToRenderCoordinates");

distinct RendererLogicalPresentation = uint;
distinct TextureAccess = uint;

module sdl3::renderer_logical_presentation;

const RendererLogicalPresentation DISABLED       =  0;
const RendererLogicalPresentation STRETCH        =  1;
const RendererLogicalPresentation LETTERBOX      =  2;
const RendererLogicalPresentation OVERSCAN       =  3;
const RendererLogicalPresentation INTEGER_SCALE  =  4;

module sdl3::texture_access;

const TextureAccess STATIC     =  0;
const TextureAccess STREAMING  =  1;
const TextureAccess TARGET     =  2;

module sdl3;

distinct Scancode = uint;

module sdl3::scancode;

const Scancode SC_UNKNOWN               =    0;
const Scancode SC_A                     =    4;
const Scancode SC_B                     =    5;
const Scancode SC_C                     =    6;
const Scancode SC_D                     =    7;
const Scancode SC_E                     =    8;
const Scancode SC_F                     =    9;
const Scancode SC_G                     =   10;
const Scancode SC_H                     =   11;
const Scancode SC_I                     =   12;
const Scancode SC_J                     =   13;
const Scancode SC_K                     =   14;
const Scancode SC_L                     =   15;
const Scancode SC_M                     =   16;
const Scancode SC_N                     =   17;
const Scancode SC_O                     =   18;
const Scancode SC_P                     =   19;
const Scancode SC_Q                     =   20;
const Scancode SC_R                     =   21;
const Scancode SC_S                     =   22;
const Scancode SC_T                     =   23;
const Scancode SC_U                     =   24;
const Scancode SC_V                     =   25;
const Scancode SC_W                     =   26;
const Scancode SC_X                     =   27;
const Scancode SC_Y                     =   28;
const Scancode SC_Z                     =   29;
const Scancode SC_1                     =   30;
const Scancode SC_2                     =   31;
const Scancode SC_3                     =   32;
const Scancode SC_4                     =   33;
const Scancode SC_5                     =   34;
const Scancode SC_6                     =   35;
const Scancode SC_7                     =   36;
const Scancode SC_8                     =   37;
const Scancode SC_9                     =   38;
const Scancode SC_0                     =   39;
const Scancode SC_RETURN                =   40;
const Scancode SC_ESCAPE                =   41;
const Scancode SC_BACKSPACE             =   42;
const Scancode SC_TAB                   =   43;
const Scancode SC_SPACE                 =   44;
const Scancode SC_MINUS                 =   45;
const Scancode SC_EQUALS                =   46;
const Scancode SC_LEFTBRACKET           =   47;
const Scancode SC_RIGHTBRACKET          =   48;
const Scancode SC_BACKSLASH             =   49;
const Scancode SC_NONUSHASH             =   50;
const Scancode SC_SEMICOLON             =   51;
const Scancode SC_APOSTROPHE            =   52;
const Scancode SC_GRAVE                 =   53;
const Scancode SC_COMMA                 =   54;
const Scancode SC_PERIOD                =   55;
const Scancode SC_SLASH                 =   56;
const Scancode SC_CAPSLOCK              =   57;
const Scancode SC_F1                    =   58;
const Scancode SC_F2                    =   59;
const Scancode SC_F3                    =   60;
const Scancode SC_F4                    =   61;
const Scancode SC_F5                    =   62;
const Scancode SC_F6                    =   63;
const Scancode SC_F7                    =   64;
const Scancode SC_F8                    =   65;
const Scancode SC_F9                    =   66;
const Scancode SC_F10                   =   67;
const Scancode SC_F11                   =   68;
const Scancode SC_F12                   =   69;
const Scancode SC_PRINTSCREEN           =   70;
const Scancode SC_SCROLLLOCK            =   71;
const Scancode SC_PAUSE                 =   72;
const Scancode SC_INSERT                =   73;
const Scancode SC_HOME                  =   74;
const Scancode SC_PAGEUP                =   75;
const Scancode SC_DELETE                =   76;
const Scancode SC_END                   =   77;
const Scancode SC_PAGEDOWN              =   78;
const Scancode SC_RIGHT                 =   79;
const Scancode SC_LEFT                  =   80;
const Scancode SC_DOWN                  =   81;
const Scancode SC_UP                    =   82;
const Scancode SC_NUMLOCKCLEAR          =   83;
const Scancode SC_KP_DIVIDE             =   84;
const Scancode SC_KP_MULTIPLY           =   85;
const Scancode SC_KP_MINUS              =   86;
const Scancode SC_KP_PLUS               =   87;
const Scancode SC_KP_ENTER              =   88;
const Scancode SC_KP_1                  =   89;
const Scancode SC_KP_2                  =   90;
const Scancode SC_KP_3                  =   91;
const Scancode SC_KP_4                  =   92;
const Scancode SC_KP_5                  =   93;
const Scancode SC_KP_6                  =   94;
const Scancode SC_KP_7                  =   95;
const Scancode SC_KP_8                  =   96;
const Scancode SC_KP_9                  =   97;
const Scancode SC_KP_0                  =   98;
const Scancode SC_KP_PERIOD             =   99;
const Scancode SC_NONUSBACKSLASH        =  100;
const Scancode SC_APPLICATION           =  101;
const Scancode SC_POWER                 =  102;
const Scancode SC_KP_EQUALS             =  103;
const Scancode SC_F13                   =  104;
const Scancode SC_F14                   =  105;
const Scancode SC_F15                   =  106;
const Scancode SC_F16                   =  107;
const Scancode SC_F17                   =  108;
const Scancode SC_F18                   =  109;
const Scancode SC_F19                   =  110;
const Scancode SC_F20                   =  111;
const Scancode SC_F21                   =  112;
const Scancode SC_F22                   =  113;
const Scancode SC_F23                   =  114;
const Scancode SC_F24                   =  115;
const Scancode SC_EXECUTE               =  116;
const Scancode SC_HELP                  =  117;
const Scancode SC_MENU                  =  118;
const Scancode SC_SELECT                =  119;
const Scancode SC_STOP                  =  120;
const Scancode SC_AGAIN                 =  121;
const Scancode SC_UNDO                  =  122;
const Scancode SC_CUT                   =  123;
const Scancode SC_COPY                  =  124;
const Scancode SC_PASTE                 =  125;
const Scancode SC_FIND                  =  126;
const Scancode SC_MUTE                  =  127;
const Scancode SC_VOLUMEUP              =  128;
const Scancode SC_VOLUMEDOWN            =  129;
const Scancode SC_KP_COMMA              =  133;
const Scancode SC_KP_EQUALSAS400        =  134;
const Scancode SC_INTERNATIONAL1        =  135;
const Scancode SC_INTERNATIONAL2        =  136;
const Scancode SC_INTERNATIONAL3        =  137;
const Scancode SC_INTERNATIONAL4        =  138;
const Scancode SC_INTERNATIONAL5        =  139;
const Scancode SC_INTERNATIONAL6        =  140;
const Scancode SC_INTERNATIONAL7        =  141;
const Scancode SC_INTERNATIONAL8        =  142;
const Scancode SC_INTERNATIONAL9        =  143;
const Scancode SC_LANG1                 =  144;
const Scancode SC_LANG2                 =  145;
const Scancode SC_LANG3                 =  146;
const Scancode SC_LANG4                 =  147;
const Scancode SC_LANG5                 =  148;
const Scancode SC_LANG6                 =  149;
const Scancode SC_LANG7                 =  150;
const Scancode SC_LANG8                 =  151;
const Scancode SC_LANG9                 =  152;
const Scancode SC_ALTERASE              =  153;
const Scancode SC_SYSREQ                =  154;
const Scancode SC_CANCEL                =  155;
const Scancode SC_CLEAR                 =  156;
const Scancode SC_PRIOR                 =  157;
const Scancode SC_RETURN2               =  158;
const Scancode SC_SEPARATOR             =  159;
const Scancode SC_OUT                   =  160;
const Scancode SC_OPER                  =  161;
const Scancode SC_CLEARAGAIN            =  162;
const Scancode SC_CRSEL                 =  163;
const Scancode SC_EXSEL                 =  164;
const Scancode SC_KP_00                 =  176;
const Scancode SC_KP_000                =  177;
const Scancode SC_THOUSANDSSEPARATOR    =  178;
const Scancode SC_DECIMALSEPARATOR      =  179;
const Scancode SC_CURRENCYUNIT          =  180;
const Scancode SC_CURRENCYSUBUNIT       =  181;
const Scancode SC_KP_LEFTPAREN          =  182;
const Scancode SC_KP_RIGHTPAREN         =  183;
const Scancode SC_KP_LEFTBRACE          =  184;
const Scancode SC_KP_RIGHTBRACE         =  185;
const Scancode SC_KP_TAB                =  186;
const Scancode SC_KP_BACKSPACE          =  187;
const Scancode SC_KP_A                  =  188;
const Scancode SC_KP_B                  =  189;
const Scancode SC_KP_C                  =  190;
const Scancode SC_KP_D                  =  191;
const Scancode SC_KP_E                  =  192;
const Scancode SC_KP_F                  =  193;
const Scancode SC_KP_XOR                =  194;
const Scancode SC_KP_POWER              =  195;
const Scancode SC_KP_PERCENT            =  196;
const Scancode SC_KP_LESS               =  197;
const Scancode SC_KP_GREATER            =  198;
const Scancode SC_KP_AMPERSAND          =  199;
const Scancode SC_KP_DBLAMPERSAND       =  200;
const Scancode SC_KP_VERTICALBAR        =  201;
const Scancode SC_KP_DBLVERTICALBAR     =  202;
const Scancode SC_KP_COLON              =  203;
const Scancode SC_KP_HASH               =  204;
const Scancode SC_KP_SPACE              =  205;
const Scancode SC_KP_AT                 =  206;
const Scancode SC_KP_EXCLAM             =  207;
const Scancode SC_KP_MEMSTORE           =  208;
const Scancode SC_KP_MEMRECALL          =  209;
const Scancode SC_KP_MEMCLEAR           =  210;
const Scancode SC_KP_MEMADD             =  211;
const Scancode SC_KP_MEMSUBTRACT        =  212;
const Scancode SC_KP_MEMMULTIPLY        =  213;
const Scancode SC_KP_MEMDIVIDE          =  214;
const Scancode SC_KP_PLUSMINUS          =  215;
const Scancode SC_KP_CLEAR              =  216;
const Scancode SC_KP_CLEARENTRY         =  217;
const Scancode SC_KP_BINARY             =  218;
const Scancode SC_KP_OCTAL              =  219;
const Scancode SC_KP_DECIMAL            =  220;
const Scancode SC_KP_HEXADECIMAL        =  221;
const Scancode SC_LCTRL                 =  224;
const Scancode SC_LSHIFT                =  225;
const Scancode SC_LALT                  =  226;
const Scancode SC_LGUI                  =  227;
const Scancode SC_RCTRL                 =  228;
const Scancode SC_RSHIFT                =  229;
const Scancode SC_RALT                  =  230;
const Scancode SC_RGUI                  =  231;
const Scancode SC_MODE                  =  257;
const Scancode SC_SLEEP                 =  258;
const Scancode SC_WAKE                  =  259;
const Scancode SC_CHANNEL_INCREMENT     =  260;
const Scancode SC_CHANNEL_DECREMENT     =  261;
const Scancode SC_MEDIA_PLAY            =  262;
const Scancode SC_MEDIA_PAUSE           =  263;
const Scancode SC_MEDIA_RECORD          =  264;
const Scancode SC_MEDIA_FAST_FORWARD    =  265;
const Scancode SC_MEDIA_REWIND          =  266;
const Scancode SC_MEDIA_NEXT_TRACK      =  267;
const Scancode SC_MEDIA_PREVIOUS_TRACK  =  268;
const Scancode SC_MEDIA_STOP            =  269;
const Scancode SC_MEDIA_EJECT           =  270;
const Scancode SC_MEDIA_PLAY_PAUSE      =  271;
const Scancode SC_MEDIA_SELECT          =  272;
const Scancode SC_AC_NEW                =  273;
const Scancode SC_AC_OPEN               =  274;
const Scancode SC_AC_CLOSE              =  275;
const Scancode SC_AC_EXIT               =  276;
const Scancode SC_AC_SAVE               =  277;
const Scancode SC_AC_PRINT              =  278;
const Scancode SC_AC_PROPERTIES         =  279;
const Scancode SC_AC_SEARCH             =  280;
const Scancode SC_AC_HOME               =  281;
const Scancode SC_AC_BACK               =  282;
const Scancode SC_AC_FORWARD            =  283;
const Scancode SC_AC_STOP               =  284;
const Scancode SC_AC_REFRESH            =  285;
const Scancode SC_AC_BOOKMARKS          =  286;
const Scancode SC_SOFTLEFT              =  287;
const Scancode SC_SOFTRIGHT             =  288;
const Scancode SC_CALL                  =  289;
const Scancode SC_ENDCALL               =  290;
const Scancode SC_RESERVED              =  400;
const Scancode SCCODES                  =  512;

module sdl3;

const float STANDARD_GRAVITY = 9.80665f;

distinct Sensor = void*;
distinct SensorID = uint;
distinct SensorType = int;

fn void close_sensor(Sensor* sensor) @extern("SDL_CloseSensor");
fn int get_sensor_data(Sensor* sensor, float* data, int num_values) @extern("SDL_GetSensorData");
fn Sensor get_sensor_from_id(SensorID instance_id) @extern("SDL_GetSensorFromID");
fn SensorID get_sensor_id(Sensor* sensor) @extern("SDL_GetSensorID");
fn ZString get_sensor_name(Sensor* sensor) @extern("SDL_GetSensorName");
fn ZString get_sensor_name_for_id(SensorID instance_id) @extern("SDL_GetSensorNameForID");
fn int get_sensor_non_portable_type(Sensor* sensor) @extern("SDL_GetSensorNonPortableType");
fn int get_sensor_non_portable_type_for_id(SensorID instance_id) @extern("SDL_GetSensorNonPortableTypeForID");
fn PropertiesID get_sensor_properties(Sensor* sensor) @extern("SDL_GetSensorProperties");
fn SensorID* get_sensors(int* count) @extern("SDL_GetSensors");
fn SensorType get_sensor_type(Sensor* sensor) @extern("SDL_GetSensorType");
fn SensorType get_sensor_type_for_id(SensorID instance_id) @extern("SDL_GetSensorTypeForID");
fn Sensor* open_sensor(SensorID instance_id) @extern("SDL_OpenSensor");
fn void update_sensors() @extern("SDL_UpdateSensors");

module sdl3::sensor_type;

const SensorType SDL_SENSOR_INVALID  =  -1;
const SensorType SDL_SENSOR_UNKNOWN  =   0;
const SensorType SDL_SENSOR_ACCEL    =   1;
const SensorType SDL_SENSOR_GYRO     =   2;
const SensorType SDL_SENSOR_ACCEL_L  =   3;
const SensorType SDL_SENSOR_GYRO_L   =   4;
const SensorType SDL_SENSOR_ACCEL_R  =   5;
const SensorType SDL_SENSOR_GYRO_R   =   6;

module sdl3;

distinct IConv_t = void*;
def FunctionPointer  =  fn void();

def MallocFunc   =  fn void*(usz size);
def CallocFunc   =  fn void*(usz nmemb, usz size);
def ReallocFunc  =  fn void*(void* mem, usz size);
def FreeFunc     =  fn void(void* mem);

const float FLT_EPSILON = 1.1920928955078125e-07F;
const int INVALID_UNICODE_CODEPOINT = 0xFFFD;

fn void free(void* mem) @extern("SDL_free");
fn void* aligned_alloc(usz alignment, usz size) @extern("SDL_aligned_alloc");
fn void aligned_free(void* mem) @extern("SDL_aligned_free");
fn void get_memory_functions(MallocFunc* malloc_func, CallocFunc* calloc_func, ReallocFunc* realloc_func, FreeFunc* free_func) @extern("SDL_GetMemoryFunctions");
fn int get_num_allocations() @extern("SDL_GetNumAllocations");
fn void get_original_memory_functions(MallocFunc* malloc_func, CallocFunc* calloc_func, ReallocFunc* realloc_func, FreeFunc* free_func) @extern("SDL_GetOriginalMemoryFunctions");
fn int set_memory_functions(MallocFunc malloc_func, CallocFunc calloc_func, ReallocFunc realloc_func, FreeFunc free_func) @extern("SDL_SetMemoryFunctions");

fn double acos(double x) @extern("SDL_acos");
fn float acosf(float x) @extern("SDL_acosf");
fn double asin(double x) @extern("SDL_asin");
fn float asinf(float x) @extern("SDL_asinf");
fn double atan(double x) @extern("SDL_atan");
fn double atan2(double y, double x) @extern("SDL_atan2");
fn float atan2f(float y, float x) @extern("SDL_atan2f");
fn float atanf(float x) @extern("SDL_atanf");
fn double ceil(double x) @extern("SDL_ceil");
fn float ceilf(float x) @extern("SDL_ceilf");
fn double copysign(double x, double y) @extern("SDL_copysign");
fn float copysignf(float x, float y) @extern("SDL_copysignf");
fn double cos(double x) @extern("SDL_cos");
fn float cosf(float x) @extern("SDL_cosf");
fn double exp(double x) @extern("SDL_exp");
fn float expf(float x) @extern("SDL_expf");
fn double fabs(double x) @extern("SDL_fabs");
fn float fabsf(float x) @extern("SDL_fabsf");
fn double floor(double x) @extern("SDL_floor");
fn float floorf(float f) @extern("SDL_floorf");
fn double fmod(double x, double y) @extern("SDL_fmod");
fn float fmodf(float x, float y) @extern("SDL_fmodf");
fn double logn(double x) @extern("SDL_log");
fn double log10(double x) @extern("SDL_log10");
fn float log10f(float x) @extern("SDL_log10f");
fn float logf(float x) @extern("SDL_logf");
fn long lround(double x) @extern("SDL_lround");
fn long lroundf(float x) @extern("SDL_lroundf");
fn double modf(double x, double* y) @extern("SDL_modf");
fn float modff(float x, float* y) @extern("SDL_modff");
fn double pow(double x, double y) @extern("SDL_pow");
fn float powf(float x, float y) @extern("SDL_powf");
fn int rand(int n) @extern("SDL_rand");
fn uint rand_bits() @extern("SDL_rand_bits");
fn uint rand_bits_r(ulong* state) @extern("SDL_rand_bits_r");
fn int rand_r(ulong state, int n) @extern("SDL_rand_r");
fn float randf() @extern("SDL_randf");
fn float randf_r(ulong* state) @extern("SDL_randf_r");
fn double round(double x) @extern("SDL_round");
fn float roundf(float x) @extern("SDL_roundf");
fn double scalbn(double x, int n) @extern("SDL_scalbn");
fn float scalbnf(float x, int n) @extern("SDL_scalbnf");
fn double sin(double x) @extern("SDL_sin");
fn float sinf(float x) @extern("SDL_sinf");
fn int size_add_overflow(usz a, usz b, usz* ret) @extern("SDL_size_add_overflow");
fn int size_mul_overflow(usz a, usz b, usz* ret  ) @extern("SDL_size_mul_overflow");
fn double sqrt(double x) @extern("SDL_sqrt");
fn float sqrtf(float x) @extern("SDL_sqrtf");
fn void srand(ulong seed) @extern("SDL_srand");
fn double tan(double x) @extern("SDL_tan");
fn float tanf(float x) @extern("SDL_tanf");
fn float truncf(float x) @extern("SDL_truncf");
fn double trunc(double x) @extern("SDL_trunc");

fn uint step_utf8(char** pstr, usz* pslen) @extern("SDL_StepUTF8");
fn int strcasecmp(ZString str1, ZString str2) @extern("SDL_strcasecmp");
fn int strcmp(ZString str1, ZString str2) @extern("SDL_strcmp");
fn ZString strlwr(ZString str) @extern("SDL_strlwr");
fn int strncasecmp(ZString str1, ZString str2, usz maxlen) @extern("SDL_strncasecmp");
fn int strncmp(ZString str1, ZString str2, usz maxlen) @extern("SDL_strncmp");
fn ZString strupr(ZString str) @extern("SDL_strupr");
fn ZString ucs4_to_utf8(uint codepoint, ZString dst) @extern("SDL_UCS4ToUTF8");
fn int wcsncmp(ZString str1, ZString str2, usz maxlen) @extern("SDL_wcsncmp");
fn int wcscasecmp(ZString str1, ZString str2) @extern("SDL_wcscasecmp");
fn int wcscmp(ZString str1, ZString str2) @extern("");
fn int wcsncasecmp(ZString str1, ZString str2, usz len) @extern("SDL_wcsncasecmp");

fn int is_alnum(int x)  @extern("SDL_isalnum");
fn int is_alpha(int x)  @extern("SDL_isalpha");
fn int is_blank(int x)  @extern("SDL_isblank");
fn int is_cntrl(int x)  @extern("SDL_iscntrl");
fn int is_digit(int x)  @extern("SDL_isdigit");
fn int is_graph(int x)  @extern("SDL_isgraph");
fn int is_inf(double x) @extern("SDL_isinf");
fn int is_inff(float x) @extern("SDL_isinff");
fn int is_lower(int x)  @extern("SDL_islower");
fn int is_nan(double x) @extern("SDL_isnan");
fn int is_nanf(float x) @extern("SDL_isnanf");
fn int is_print(int x)  @extern("SDL_isprint");
fn int is_punct(int x)  @extern("SDL_ispunct");
fn int is_space(int x)  @extern("SDL_isspace");
fn int is_upper(int x ) @extern("SDL_isupper");
fn int is_xdigit(int x) @extern("SDL_isxdigit");
fn int to_lower(int x)  @extern("SDL_tolower");
fn int to_upper(int x)  @extern("SDL_toupper");

fn usz iconv(IConv_t cd, char** inbuf, usz* inbytesleft, char** outbuf, usz* outbytesleft) @extern("SDL_iconv");
fn int iconv_close(IConv_t cd) @extern("SDL_iconv_close");
fn IConv_t iconv_open(ZString tocode, ZString fromcode) @extern("SDL_iconv_open");
fn ZString iconv_string(ZString tocode, ZString fromcode, ZString inbuf, usz inbytesleft) @extern("SDL_iconv_string");

module sdl3;

distinct Storage = void*;

def SpaceRemainingCallback = fn ulong(void* userdata);
def StorageCloseCallback = fn int(void* userdata);
def StorageCopyCallback = fn int(void* userdata, ZString oldpath, ZString newpath);
def StorageEnumerateCallback = fn int(void* userdata, ZString path, EnumerateDirectoryCallback callback, void* callback_userdata);
def StorageInfoCallback = fn int(void* userdata, ZString path, PathInfo* info);
def StorageMkdirCallback = fn int(void* userdata, ZString path);
def StorageReadFileCallback = fn int(void* userdata, ZString path, void* destination, ulong length);
def StorageReadyCallback = fn bool(void* userdata);
def StorageRemoveCallback = fn int(void* userdata, ZString path);
def StorageRenameCallback = fn int(void* userdata, ZString oldpath, ZString newpath);
def StorageWriteFileCallback = fn int(void* userdata, ZString path, void* source, ulong length);

struct StorageInterface
{
    StorageCloseCallback     storage_close;
    StorageReadyCallback     storage_ready;
    StorageEnumerateCallback storage_enumerate;
    StorageInfoCallback      storage_info;
    StorageReadFileCallback  storage_read_file;
    StorageWriteFileCallback storage_write_file;
    StorageMkdirCallback     storage_mkdir;
    StorageRemoveCallback    storage_remove;
    StorageRenameCallback    storage_rename;
    StorageCopyCallback      storage_copy;
    SpaceRemainingCallback   space_remaining;
}

fn int close_storage(Storage* storage) @extern("SDL_CloseStorage");
fn int copy_storage_file(Storage* storage, ZString oldpath, ZString newpath) @extern("SDL_CopyStorageFile");
fn int create_storage_directory(Storage* storage, ZString path) @extern("SDL_CreateStorageDirectory");
fn int enumerate_storage_directory(Storage* storage, ZString path, EnumerateDirectoryCallback callback, void* userdata) @extern("SDL_EnumerateStorageDirectory");
fn int get_storage_file_size(Storage* storage, ZString path, ulong* length) @extern("SDL_GetStorageFileSize");
fn int get_storage_path_info(Storage* storage, ZString path, PathInfo* info) @extern("SDL_GetStoragePathInfo");
fn ulong get_storage_space_remaining(Storage* storage) @extern("SDL_GetStorageSpaceRemaining");

fn char** _glob_storage_directory(Storage* storage, ZString path, ZString pattern, GlobFlags flags, int* count) @extern("SDL_GlobStorageDirectory") @local;

macro ZString[] glob_storage_directory(Storage* storage, ZString path, ZString pattern = null, GlobFlags flags = glob_flags::CASEINSENSITIVE)
{
    int count;
    char** _files = _glob_storage_directory(storage, path, pattern, flags, &count);

    ZString[] files = mem::new_array(ZString, count);
    for (int i = 0; i < count; ++i) files[i] = (ZString)_files[i];
    return files;
}

fn Storage* open_file_storage(ZString path) @extern("SDL_OpenFileStorage");
fn Storage* open_storage(StorageInterface* iface, void* userdata) @extern("SDL_OpenStorage");
fn Storage* open_title_storage(ZString override, PropertiesID props) @extern("SDL_OpenTitleStorage");
fn Storage* open_user_storage(ZString org, ZString app, PropertiesID props) @extern("SDL_OpenUserStorage");
fn int read_storage_file(Storage* storage, ZString path, void* destination, ulong length) @extern("SDL_ReadStorageFile");
fn int remove_storage_path(Storage* storage, ZString path) @extern("SDL_RemoveStoragePath");
fn int rename_storage_path(Storage* storage, ZString oldpath, ZString newpath) @extern("SDL_RenameStoragePath");
fn bool storage_ready(Storage* storage) @extern("SDL_StorageReady");
fn int write_storage_file(Storage* storage, ZString path, void* source, ulong length) @extern("SDL_WriteStorageFile");

module sdl3;

distinct SurfaceFlags = uint;
distinct SurfaceData = void*;
distinct ScaleMode = uint;
distinct FlipMode = uint;

struct Surface
{
    SurfaceFlags flags;
    PixelFormat format;
    int w, h; 
    int pitch;
    void* pixels;
    int refcount;
    SurfaceData* internal;
}

fn int add_surface_alternate_image(Surface* surface, Surface* image) @extern("SDL_AddSurfaceAlternateImage");
fn int blit_surface(Surface* src, Rect* srcrect, Surface* dst, Rect* dstrect) @extern("SDL_BlitSurface");
fn int blit_surface9_grid(Surface* src, Rect* srcrect, int left_width, int right_width, int top_height, int bottom_height, float scale, ScaleMode scaleMode, Surface* dst, Rect* dstrect)
 @extern("SDL_BlitSurface9Grid");
fn int blit_surface_scaled(Surface* src, Rect* srcrect, Surface* dst, Rect* dstrect, ScaleMode scaleMode) @extern("SDL_BlitSurfaceScaled");
fn int blit_surface_tiled(Surface* src, Rect* srcrect, Surface* dst, Rect* dstrect) @extern("SDL_BlitSurfaceTiled");
fn int blit_surface_tiled_with_scale(Surface* src, Rect* srcrect, float scale, ScaleMode scaleMode, Surface* dst, Rect* dstrect) @extern("SDL_BlitSurfaceTiledWithScale");
fn int blit_surface_unchecked(Surface* src, Rect* srcrect, Surface* dst, Rect* dstrect) @extern("SDL_BlitSurfaceUnchecked");
fn int blit_surface_unchecked_scaled(Surface* src, Rect* srcrect, Surface* dst, Rect* dstrect, ScaleMode scaleMode) @extern("SDL_BlitSurfaceUncheckedScaled");
fn int clear_surface(Surface* surface, float r, float g, float b, float a) @extern("SDL_ClearSurface");
fn int convert_pixels(int width, int height, PixelFormat src_format, void* src, int src_pitch, PixelFormat dst_format, void* dst, int dst_pitch) @extern("SDL_ConvertPixels");
fn int convert_pixels_and_colorspace(int width, int height, PixelFormat src_format, Colorspace src_colorspace, PropertiesID src_properties, void* src, int src_pitch, PixelFormat dst_format, Colorspace dst_colorspace, PropertiesID dst_properties, void* dst, int dst_pitch) @extern("SDL_ConvertPixelsAndColorspace");
fn Surface* convert_surface(Surface* surface, PixelFormat format) @extern("SDL_ConvertSurface");
fn Surface* convert_surface_and_colorspace(Surface* surface, PixelFormat format, Palette* palette, Colorspace colorspace, PropertiesID props) @extern("SDL_ConvertSurfaceAndColorspace");
fn Surface* create_surface(int width, int height, PixelFormat format) @extern("SDL_CreateSurface");
fn Surface* create_surface_from(int width, int height, PixelFormat format, void* pixels, int pitch) @extern("SDL_CreateSurfaceFrom");
fn Palette* create_surface_palette(Surface* surface) @extern("SDL_CreateSurfacePalette");
fn void destroy_surface(Surface* surface) @extern("SDL_DestroySurface");
fn Surface* duplicate_surface(Surface* surface) @extern("SDL_DuplicateSurface");
fn int fill_surface_rect(Surface* dst, Rect* rect, uint color) @extern("SDL_FillSurfaceRect");
fn int fill_surface_rects(Surface* dst, Rect* rects, int count, uint color) @extern("SDL_FillSurfaceRects");
fn int flip_surface(Surface* surface, FlipMode flip) @extern("SDL_FlipSurface");
fn int get_surface_alpha_mod(Surface* surface, ZString alpha) @extern("SDL_GetSurfaceAlphaMod");
fn int get_surface_blend_mode(Surface* surface, BlendMode* blendMode) @extern("SDL_GetSurfaceBlendMode");
fn int get_surface_clip_rect(Surface* surface, Rect* rect) @extern("SDL_GetSurfaceClipRect");
fn int get_surface_color_key(Surface* surface, uint* key) @extern("SDL_GetSurfaceColorKey");
fn int get_surface_color_mod(Surface* surface, ZString r, ZString g, ZString b) @extern("SDL_GetSurfaceColorMod");
fn Colorspace get_surface_colorspace(Surface* surface) @extern("SDL_GetSurfaceColorspace");

fn Surface** _get_surface_images(Surface* surface, int* count) @extern("SDL_GetSurfaceImages") @local;

macro Surface[] get_surface_images(Surface* surface)
{
    int count;
    Surface** _surfaces = _get_surface_images(surface, &count);

    Surface[] surfaces = mem::new_array(Surface, count);
    for (int i = 0; i < count; ++i) surfaces[i] = (Surface)*_surfaces[i];
    return surfaces;
}

fn Palette* get_surface_palette(Surface* surface) @extern("SDL_GetSurfacePalette");
fn PropertiesID get_surface_properties(Surface* surface) @extern("SDL_GetSurfaceProperties");
fn Surface* load_bmp(ZString file) @extern("SDL_LoadBMP");
fn Surface* load_bmp_io(IOStream* src, bool closeio) @extern("SDL_LoadBMP_IO");
fn int lock_surface(Surface* surface) @extern("SDL_LockSurface");
fn uint map_surface_rgb(Surface* surface, char r, char g, char b) @extern("SDL_MapSurfaceRGB");
fn uint map_surface_rgba(Surface* surface, char r, char g, char b, char a) @extern("SDL_MapSurfaceRGBA");
fn int premultiply_alpha(int width, int height, PixelFormat src_format, void* src, int src_pitch, PixelFormat dst_format, void* dst, int dst_pitch, bool linear) @extern("SDL_PremultiplyAlpha");
fn int premultiply_surface_alpha(Surface* surface, bool linear) @extern("SDL_PremultiplySurfaceAlpha");
fn int read_surface_pixel(Surface* surface, int x, int y, ZString r, ZString g, ZString b, ZString a) @extern("SDL_ReadSurfacePixel");
fn int read_surface_pixel_float(Surface* surface, int x, int y, float* r, float* g, float* b, float* a) @extern("SDL_ReadSurfacePixelFloat");
fn void remove_surface_alternate_images(Surface* surface) @extern("SDL_RemoveSurfaceAlternateImages");
fn int save_bmp(Surface* surface, ZString file) @extern("SDL_SaveBMP");
fn int save_bmp_io(Surface* surface, IOStream* dst, bool closeio) @extern("SDL_SaveBMP_IO");
fn Surface* scale_surface(Surface* surface, int width, int height, ScaleMode scaleMode) @extern("SDL_ScaleSurface");
fn int set_surface_alpha_mod(Surface* surface, char alpha) @extern("SDL_SetSurfaceAlphaMod");
fn int set_surface_blend_mode(Surface* surface, BlendMode blendMode) @extern("SDL_SetSurfaceBlendMode");
fn bool set_surface_clip_rect(Surface* surface, Rect* rect) @extern("SDL_SetSurfaceClipRect");
fn int set_surface_color_key(Surface* surface, bool enabled, uint key) @extern("SDL_SetSurfaceColorKey");
fn int set_surface_color_mod(Surface* surface, char r, char g, char b) @extern("SDL_SetSurfaceColorMod");
fn int set_surface_colorspace(Surface* surface, Colorspace colorspace) @extern("SDL_SetSurfaceColorspace");
fn int set_surface_palette(Surface* surface, Palette* palette) @extern("SDL_SetSurfacePalette");
fn int set_surface_rle(Surface* surface, bool enabled) @extern("SDL_SetSurfaceRLE");
fn bool surface_has_alternate_images(Surface* surface) @extern("SDL_SurfaceHasAlternateImages");
fn bool surface_has_color_key(Surface* surface) @extern("SDL_SurfaceHasColorKey");
fn bool surface_has_rle(Surface* surface) @extern("SDL_SurfaceHasRLE");
fn void unlock_surface(Surface* surface) @extern("SDL_UnlockSurface");
fn int write_surface_pixel(Surface* surface, int x, int y, char r, char g, char b, char a) @extern("SDL_WriteSurfacePixel");
fn int write_surface_pixel_float(Surface* surface, int x, int y, float r, float g, float b, float a) @extern("SDL_WriteSurfacePixelFloat");

module sdl3::surface_flags;

const SurfaceFlags PREALLOCATED  =  0x00000001u;
const SurfaceFlags LOCK_NEEDED   =  0x00000002u;
const SurfaceFlags LOCKED        =  0x00000004u;
const SurfaceFlags SIMD_ALIGNED  =  0x00000008u;

module sdl3::scale_mode;

const ScaleMode NEAREST  =  0;
const ScaleMode LINEAR   =  1;
const ScaleMode BEST     =  2;

module sdl3::flip_mode;

const FlipMode NONE        =  0;
const FlipMode HORIZONTAL  =  1;
const FlipMode VERTICAL    =  2;

module sdl3;

distinct Win32Msg = void*;
distinct WinRT_DeviceFamily = uint;
distinct WinRT_Path = uint;

distinct XTaskQueueHandle = void*;
distinct XUserHandle = void*;
distinct XEvent = void*;

def IOSAnimationCallback = fn void(void* userdata) @if(env::DARWIN);
def WindowsMessageHook = fn bool(void* userdata, Win32Msg* msg) @if(env::WIN32);
def RequestAndroidPermissionCallback = fn void(void* userdata, ZString permission, bool granted);
def X11EventHook= fn bool(void* userdata, XEvent* xevent);

const uint ANDROID_EXTERNAL_STORAGE_READ = 0x01;

fn void* get_android_activity() @extern("SDL_GetAndroidActivity");
fn ZString get_android_cache_path() @extern("SDL_GetAndroidCachePath");
fn ZString get_android_external_storage_path() @extern("SDL_GetAndroidExternalStoragePath");
fn uint get_android_external_storage_state() @extern("SDL_GetAndroidExternalStorageState");
fn ZString get_android_internal_storage_path() @extern("SDL_GetAndroidInternalStoragePath");
fn void* get_android_jni_env() @extern("SDL_GetAndroidJNIEnv");
fn int get_android_sdk_version() @extern("SDL_GetAndroidSDKVersion");
fn int get_direct3d9_adapter_index(DisplayID displayID) @extern("SDL_GetDirect3D9AdapterIndex");
fn int get_dxgi_output_info(DisplayID displayID, int* adapterIndex, int* outputIndex) @extern("SDL_GetDXGIOutputInfo");
fn int get_gdk_default_user(XUserHandle* outUserHandle) @extern("SDL_GetGDKDefaultUser");
fn int get_gdk_task_queue(XTaskQueueHandle* outTaskQueue) @extern("SDL_GetGDKTaskQueue");
fn WinRT_DeviceFamily get_win_rt_device_family() @extern("SDL_GetWinRTDeviceFamily")  @if(env::WIN32);
fn ZString get_win_rtfs_path(WinRT_Path pathType) @extern("SDL_GetWinRTFSPath")  @if(env::WIN32);
fn bool is_android_tv() @extern("SDL_IsAndroidTV");
fn bool is_chromebook() @extern("SDL_IsChromebook");
fn bool is_de_x_mode() @extern("SDL_IsDeXMode");
fn bool is_tablet() @extern("SDL_IsTablet");
fn void on_application_did_change_status_bar_orientation() @extern("SDL_OnApplicationDidChangeStatusBarOrientation");
fn void on_application_did_enter_background() @extern("SDL_OnApplicationDidEnterBackground");
fn void on_application_did_enter_foreground() @extern("SDL_OnApplicationDidEnterForeground");
fn void on_application_did_receive_memory_warning() @extern("SDL_OnApplicationDidReceiveMemoryWarning");
fn void on_application_will_enter_background() @extern("SDL_OnApplicationWillEnterBackground");
fn void on_application_will_enter_foreground() @extern("SDL_OnApplicationWillEnterForeground");
fn void on_application_will_terminate() @extern("SDL_OnApplicationWillTerminate");
fn int request_android_permission(ZString permission, RequestAndroidPermissionCallback cb, void* userdata) @extern("SDL_RequestAndroidPermission");
fn void send_android_back_button() @extern("SDL_SendAndroidBackButton");
fn int send_android_message(uint command, int param) @extern("SDL_SendAndroidMessage");
fn int set_ios_animation_callback(Window* window, int interval, IOSAnimationCallback callback, void* callbackParam) @extern("SDL_SetiOSAnimationCallback") @if(env::DARWIN);
fn int set_ios_event_pump(bool enabled) @extern("SDL_SetiOSEventPump") @if(env::DARWIN);
fn int set_linux_thread_priority(long threadID, int priority) @extern("SDL_SetLinuxThreadPriority");
fn int set_linux_thread_priority_and_policy(long threadID, int sdlPriority, int schedPolicy) @extern("SDL_SetLinuxThreadPriorityAndPolicy");
fn void set_windows_message_hook(WindowsMessageHook callback, void* userdata) @extern("SDL_SetWindowsMessageHook")  @if(env::WIN32);
fn void set_x11_event_hook(X11EventHook callback, void* userdata) @extern("SDL_SetX11EventHook");
fn int show_android_toast(ZString message, int duration, int gravity, int xoffset, int yoffset) @extern("SDL_ShowAndroidToast");

module sdl3::win_rt_device_family;

const WinRT_DeviceFamily UNKNOWN  =  0;
const WinRT_DeviceFamily DESKTOP  =  1;
const WinRT_DeviceFamily MOBILE   =  2;
const WinRT_DeviceFamily XBOX     =  3;

module sdl3::win_rt_path;

const WinRT_Path INSTALLED_LOCATION  =  0;
const WinRT_Path LOCAL_FOLDER        =  1;
const WinRT_Path ROAMING_FOLDER      =  2;
const WinRT_Path TEMP_FOLDER         =  3;

module sdl3;

distinct Thread = void*;
distinct ThreadID = ulong;
distinct ThreadPriority = uint;
distinct ThreadLocalStorageID = AtomicInt;

def ThreadFunction = fn int(void* data);
def TLSDestructorCallback = fn void(void* value);

fn void cleanup_tls() @extern("SDL_CleanupTLS");
fn Thread* create_thread(ThreadFunction func, ZString name, void* data) @extern("SDL_CreateThread");
fn Thread* create_thread_with_properties(PropertiesID props) @extern("SDL_CreateThreadWithProperties");
fn void detach_thread(Thread* thread) @extern("SDL_DetachThread");
fn ThreadID get_current_thread_id() @extern("SDL_GetCurrentThreadID");
fn ThreadID get_thread_id(Thread* thread) @extern("SDL_GetThreadID");
fn ZString get_thread_name(Thread* thread) @extern("SDL_GetThreadName");
fn void* get_tls(ThreadLocalStorageID* id) @extern("SDL_GetTLS");
fn int set_thread_priority(ThreadPriority priority) @extern("SDL_SetThreadPriority");
fn int set_tls(ThreadLocalStorageID* id, void* value, TLSDestructorCallback destructor) @extern("SDL_SetTLS");
fn void wait_thread(Thread* thread, int* status) @extern("SDL_WaitThread");

module sdl3::thread_priority;

const ThreadPriority LOW            =  0;
const ThreadPriority NORMAL         =  1;
const ThreadPriority HIGH           =  2;
const ThreadPriority TIME_CRITICAL  =  3;

module sdl3;

distinct Time = long;

distinct DateFormat = int;
distinct TimeFormat = int;

struct DateTime
{
    int year;
    int month;
    int day;
    int hour;
    int minute;
    int second;
    int nanosecond;
    int day_of_week;
    int utc_offset;
}

fn int date_time_to_time(DateTime* dt, Time* ticks) @extern("SDL_DateTimeToTime");
fn int get_current_time(Time* ticks) @extern("SDL_GetCurrentTime");
fn int get_date_time_locale_preferences(DateFormat* dateFormat, TimeFormat* timeFormat) @extern("SDL_GetDateTimeLocalePreferences");
fn int get_day_of_week(int year, int month, int day) @extern("SDL_GetDayOfWeek");
fn int get_day_of_year(int year, int month, int day) @extern("SDL_GetDayOfYear");
fn int get_days_in_month(int year, int month) @extern("SDL_GetDaysInMonth");
fn Time time_from_windows(uint dwLowDateTime, uint dwHighDateTime) @extern("SDL_TimeFromWindows");
fn int time_to_date_time(Time ticks, DateTime* dt, bool localTime) @extern("SDL_TimeToDateTime");
fn void time_to_windows(Time ticks, uint* dwLowDateTime, uint* dwHighDateTime) @extern("SDL_TimeToWindows");

module sdl3::date_format;

const DateFormat YYYYMMDD = 0;
const DateFormat DDMMYYYY = 1;
const DateFormat MMDDYYYY = 2;

module sdl3::time_format;

const TimeFormat HR_24 = 0;
const TimeFormat HR_12 = 1;

module sdl3;

distinct TimerID = uint;

def NSTimerCallback = fn ulong(void* userdata, TimerID timerID, ulong interval);
def TimerCallback = fn uint (void* userdata, TimerID timerID, uint interval);

fn TimerID add_timer(uint interval, TimerCallback callback, void* userdata) @extern("SDL_AddTimer");
fn TimerID add_timer_ns(ulong interval, NSTimerCallback callback, void* userdata) @extern("SDL_AddTimerNS");
fn void delay(uint ms) @extern("SDL_Delay");
fn void delay_ns(ulong ns) @extern("SDL_DelayNS");
fn ulong get_performance_counter() @extern("SDL_GetPerformanceCounter");
fn ulong get_performance_frequency() @extern("SDL_GetPerformanceFrequency");
fn ulong get_ticks() @extern("SDL_GetTicks");
fn ulong get_ticks_ns() @extern("SDL_GetTicksNS");
fn int remove_timer(TimerID id) @extern("SDL_RemoveTimer");

module sdl3;

distinct FingerID = ulong;
distinct TouchID = ulong;
distinct TouchDeviceType = int;

struct Finger
{
    FingerID id;
    float x;
    float y;
    float pressure;
}

fn ZString get_touch_device_name(TouchID touchID) @extern("SDL_GetTouchDeviceName");
fn TouchID * get_touch_devices(int* count) @extern("SDL_GetTouchDevices");
fn TouchDeviceType get_touch_device_type(TouchID touchID) @extern("SDL_GetTouchDeviceType");

fn Finger** _get_touch_fingers(TouchID touchID, int* count) @extern("SDL_GetTouchFingers") @local;

macro Finger[] get_touch_fingers(TouchID touchID)
{
    int count;
    Finger** _fingers = _get_touch_fingers(touchID, &count);

    Finger[] fingers = mem::new_array(Finger, count);
    for(int i = 0; i < count; ++i) fingers[i] = (Finger)*_fingers[i];
    return fingers;
}

module sdl3::touch_device_type;

const TouchDeviceType SDL_TOUCH_DEVICE_INVALID            =  -1;
const TouchDeviceType SDL_TOUCH_DEVICE_DIRECT             =   0;
const TouchDeviceType SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE  =   1;
const TouchDeviceType SDL_TOUCH_DEVICE_INDIRECT_RELATIVE  =   2;

module sdl3;

fn ZString get_revision() @extern("SDL_GetRevision");
fn int get_version() @extern("SDL_GetVersion");

macro int versionnum_major(int version) => ((version) / 1000000);
macro int versionnum_minor(version) => (((version) / 1000) % 1000);
macro int versionnum_micro(int version) => ((version) % 1000);

module sdl3;

distinct Window = void*;
distinct WindowFlags = ulong;
distinct WindowProperty = inline char*;
distinct WindowID = uint;

distinct DisplayID = uint;
distinct DisplayModeData = void*;
distinct DisplayOrientation = int;

distinct SystemTheme = int;
distinct FlashOperation = int;

distinct EGLDisplay = void*;
distinct EGLConfig  = void*;
distinct EGLSurface = void*;
distinct EGLAttrib  = void*;
distinct EGLint = int;

def EGLAttribArrayCallback = fn EGLAttrib*();
def EGLIntArrayCallback = fn EGLint*();

distinct GLContext = void*;
distinct GLattr = uint;

distinct HitTestResult = uint;
def HitTest = fn HitTestResult(Window* win, Point* area, void* data);

struct DisplayMode
{
    DisplayID displayID;
    PixelFormat format;
    int w;
    int h;
    float pixel_density;
    float refresh_rate;
    int refresh_rate_numerator;
    int refresh_rate_denominator;
    DisplayModeData* internal;
}

fn Window* create_popup_window(Window* parent, int offset_x, int offset_y, int w, int h, WindowFlags flags) @extern("SDL_CreatePopupWindow");
fn Window* create_window(ZString title, int w, int h, WindowFlags flags) @extern("SDL_CreateWindow");
fn Window* create_window_with_properties(PropertiesID props) @extern("SDL_CreateWindowWithProperties");
fn void destroy_window(Window* window) @extern("SDL_DestroyWindow");
fn int destroy_window_surface(Window* window) @extern("SDL_DestroyWindowSurface");
fn int disable_screen_saver() @extern("SDL_DisableScreenSaver");
fn int enable_screen_saver() @extern("SDL_EnableScreenSaver");
fn int flash_window(Window* window, FlashOperation operation) @extern("SDL_FlashWindow");
fn int show_window(Window* window) @extern("SDL_ShowWindow");
fn int get_window_aspect_ratio(Window* window, float* min_aspect, float* max_aspect) @extern("SDL_GetWindowAspectRatio");
fn int get_window_borders_size(Window* window, int* top, int* left, int* bottom, int* right) @extern("SDL_GetWindowBordersSize");
fn float get_window_display_scale(Window* window) @extern("SDL_GetWindowDisplayScale");
fn WindowFlags get_window_flags(Window* window) @extern("SDL_GetWindowFlags");
fn Window* get_window_from_id(WindowID id) @extern("SDL_GetWindowFromID");
fn DisplayMode* get_window_fullscreen_mode(Window* window) @extern("SDL_GetWindowFullscreenMode");
fn void* get_window_icc_profile(Window* window, usz* size) @extern("SDL_GetWindowICCProfile");
fn WindowID get_window_id(Window* window) @extern("SDL_GetWindowID");
fn bool get_window_keyboard_grab(Window* window) @extern("SDL_GetWindowKeyboardGrab");
fn int get_window_maximum_size(Window* window, int* w, int* h) @extern("SDL_GetWindowMaximumSize");
fn int get_window_minimum_size(Window* window, int* w, int* h) @extern("SDL_GetWindowMinimumSize");
fn bool get_window_mouse_grab(Window* window) @extern("SDL_GetWindowMouseGrab");
fn Rect* get_window_mouse_rect(Window* window) @extern("SDL_GetWindowMouseRect");
fn float get_window_opacity(Window* window) @extern("SDL_GetWindowOpacity");
fn Window* get_window_parent(Window* window) @extern("SDL_GetWindowParent");
fn float get_window_pixel_density(Window* window) @extern("SDL_GetWindowPixelDensity");
fn PixelFormat get_window_pixel_format(Window* window) @extern("SDL_GetWindowPixelFormat");
fn int get_window_position(Window* window, int* x, int* y) @extern("SDL_GetWindowPosition");
fn PropertiesID get_window_properties(Window* window) @extern("SDL_GetWindowProperties");

fn Window** _get_windows(int* count) @extern("SDL_GetWindows") @local;

macro Window[] get_windows()
{
    int count;
    Window** wins = _get_windows(&count);

    Window[] windows = mem::new_array(Window, count);
    for (int i = 0; i < count; ++i) windows[i] = (Window)wins[i];
    return windows;
}

fn int get_window_safe_area(Window* window, Rect* rect) @extern("SDL_GetWindowSafeArea");
fn int get_window_size(Window* window, int* w, int* h) @extern("SDL_GetWindowSize");
fn int get_window_size_in_pixels(Window* window, int* w, int* h) @extern("SDL_GetWindowSizeInPixels");
fn Surface* get_window_surface(Window* window) @extern("SDL_GetWindowSurface");
fn int get_window_surface_v_sync(Window* window, int* vsync) @extern("SDL_GetWindowSurfaceVSync");
fn ZString get_window_title(Window* window) @extern("SDL_GetWindowTitle");
fn int hide_window(Window* window) @extern("SDL_HideWindow");
fn int maximize_window(Window* window) @extern("SDL_MaximizeWindow");
fn int minimize_window(Window* window) @extern("SDL_MinimizeWindow");
fn int raise_window(Window* window) @extern("SDL_RaiseWindow");
fn int restore_window(Window* window) @extern("SDL_RestoreWindow");
fn bool screen_saver_enabled() @extern("SDL_ScreenSaverEnabled");
fn int set_window_always_on_top(Window* window, bool on_top) @extern("SDL_SetWindowAlwaysOnTop");
fn int set_window_aspect_ratio(Window* window, float min_aspect, float max_aspect) @extern("SDL_SetWindowAspectRatio");
fn int set_window_bordered(Window* window, bool bordered) @extern("SDL_SetWindowBordered");
fn int set_window_focusable(Window* window, bool focusable) @extern("SDL_SetWindowFocusable");
fn int set_window_fullscreen(Window* window, bool fullscreen) @extern("SDL_SetWindowFullscreen");
fn int set_window_fullscreen_mode(Window* window, DisplayMode* mode) @extern("SDL_SetWindowFullscreenMode");
fn int set_window_hit_test(Window* window, HitTest callback, void* callback_data) @extern("SDL_SetWindowHitTest");
fn int set_window_icon(Window* window, Surface* icon) @extern("SDL_SetWindowIcon");
fn int set_window_keyboard_grab(Window* window, bool grabbed) @extern("SDL_SetWindowKeyboardGrab");
fn int set_window_maximum_size(Window* window, int max_w, int max_h) @extern("SDL_SetWindowMaximumSize");
fn int set_window_minimum_size(Window* window, int min_w, int min_h) @extern("SDL_SetWindowMinimumSize");
fn int set_window_modal_for(Window* modal_window, Window* parent_window) @extern("SDL_SetWindowModalFor");
fn int set_window_mouse_grab(Window* window, bool grabbed) @extern("SDL_SetWindowMouseGrab");
fn int set_window_mouse_rect(Window* window, Rect* rect) @extern("SDL_SetWindowMouseRect");
fn int set_window_opacity(Window* window, float opacity) @extern("SDL_SetWindowOpacity");
fn int set_window_position(Window* window, int x, int y) @extern("SDL_SetWindowPosition");
fn int set_window_resizable(Window* window, bool resizable) @extern("SDL_SetWindowResizable");
fn int set_window_shape(Window* window, Surface* shape) @extern("SDL_SetWindowShape");
fn int set_window_size(Window* window, int w, int h) @extern("SDL_SetWindowSize");
fn int set_window_surface_v_sync(Window* window, int vsync) @extern("SDL_SetWindowSurfaceVSync");
fn int set_window_title(Window* window, ZString title) @extern("SDL_SetWindowTitle");
fn int show_window_system_menu(Window* window, int x, int y) @extern("SDL_ShowWindowSystemMenu");
fn int sync_window(Window* window) @extern("SDL_SyncWindow");
fn int update_window_surface(Window* window) @extern("SDL_UpdateWindowSurface");
fn int update_window_surface_rects(Window* window, Rect* rects, int numrects) @extern("SDL_UpdateWindowSurfaceRects");
fn bool window_has_surface(Window* window) @extern("SDL_WindowHasSurface");
fn int get_closest_fullscreen_display_mode(DisplayID displayID, int w, int h, float refresh_rate, bool include_high_density_modes,DisplayMode* mode) @extern("SDL_GetClosestFullscreenDisplayMode");
fn DisplayMode* get_current_display_mode(DisplayID displayID) @extern("SDL_GetCurrentDisplayMode");
fn DisplayOrientation get_current_display_orientation(DisplayID displayID) @extern("SDL_GetCurrentDisplayOrientation");
fn ZString get_current_video_driver() @extern("SDL_GetCurrentVideoDriver");
fn DisplayMode* get_desktop_display_mode(DisplayID displayID) @extern("SDL_GetDesktopDisplayMode");
fn int get_display_bounds(DisplayID displayID, Rect* rect) @extern("SDL_GetDisplayBounds");
fn float get_display_content_scale(DisplayID displayID) @extern("SDL_GetDisplayContentScale");
fn DisplayID get_display_for_point(Point* point) @extern("SDL_GetDisplayForPoint");
fn DisplayID get_display_for_rect(Rect* rect) @extern("SDL_GetDisplayForRect");
fn DisplayID get_display_for_window(Window* window) @extern("SDL_GetDisplayForWindow");
fn ZString get_display_name(DisplayID displayID) @extern("SDL_GetDisplayName");
fn PropertiesID get_display_properties(DisplayID displayID) @extern("SDL_GetDisplayProperties");
fn DisplayID* get_displays(int* count) @extern("SDL_GetDisplays");
fn int get_display_usable_bounds(DisplayID displayID, Rect* rect) @extern("SDL_GetDisplayUsableBounds");
fn DisplayMode** get_fullscreen_display_modes(DisplayID displayID, int* count) @extern("SDL_GetFullscreenDisplayModes");
fn Window* get_grabbed_window() @extern("SDL_GetGrabbedWindow");
fn DisplayOrientation get_natural_display_orientation(DisplayID displayID) @extern("SDL_GetNaturalDisplayOrientation");
fn DisplayID get_primary_display() @extern("SDL_GetPrimaryDisplay");
fn int get_num_video_drivers() @extern("SDL_GetNumVideoDrivers");
fn ZString get_video_driver(int index) @extern("SDL_GetVideoDriver");
fn SystemTheme get_system_theme() @extern("SDL_GetSystemTheme");
fn GLContext* gl_create_context(Window* window) @extern("SDL_GL_CreateContext");
fn int gl_destroy_context(GLContext context) @extern("SDL_GL_DestroyContext");
fn bool gl_extension_supported(ZString extension) @extern("SDL_GL_ExtensionSupported");
fn int gl_get_attribute(GLattr attr, int* value) @extern("SDL_GL_GetAttribute");
fn GLContext gl_get_current_context() @extern("SDL_GL_GetCurrentContext");
fn Window* gl_get_current_window() @extern("SDL_GL_GetCurrentWindow");
fn FunctionPointer gl_get_proc_address(ZString proc) @extern("SDL_GL_GetProcAddress");
fn int gl_get_swap_interval(int* interval) @extern("SDL_GL_GetSwapInterval");
fn int gl_load_library(ZString path) @extern("SDL_GL_LoadLibrary");
fn int gl_make_current(Window* window, GLContext context) @extern("SDL_GL_MakeCurrent");
fn void gl_reset_attributes() @extern("SDL_GL_ResetAttributes");
fn int gl_set_attribute(GLattr attr, int value) @extern("SDL_GL_SetAttribute");
fn int gl_set_swap_interval(int interval) @extern("SDL_GL_SetSwapInterval");
fn int gl_swap_window(Window* window,) @extern("SDL_GL_SwapWindow");
fn void gl_unload_library() @extern("SDL_GL_UnloadLibrary");
fn EGLConfig egl_get_current_config() @extern("SDL_EGL_GetCurrentConfig");
fn EGLDisplay egl_get_current_display() @extern("SDL_EGL_GetCurrentDisplay");
fn FunctionPointer egl_get_proc_address(ZString proc) @extern("SDL_EGL_GetProcAddress");
fn EGLSurface egl_get_window_surface(Window* window) @extern("SDL_EGL_GetWindowSurface");
fn void egl_set_attribute_callbacks(EGLAttribArrayCallback platformAttribCallback, EGLIntArrayCallback surfaceAttribCallback, EGLIntArrayCallback contextAttribCallback) @extern("SDL_EGL_SetAttributeCallbacks");


module sdl3::windows_flags;

const WindowFlags FULLSCREEN           =  0x0000000000000001;
const WindowFlags OPENGL               =  0x0000000000000002;
const WindowFlags OCCLUDED             =  0x0000000000000004;
const WindowFlags HIDDEN               =  0x0000000000000008;
const WindowFlags BORDERLESS           =  0x0000000000000010;
const WindowFlags RESIZABLE            =  0x0000000000000020;
const WindowFlags MINIMIZED            =  0x0000000000000040;
const WindowFlags MAXIMIZED            =  0x0000000000000080;
const WindowFlags MOUSE_GRABBED        =  0x0000000000000100;
const WindowFlags INPUT_FOCUS          =  0x0000000000000200;
const WindowFlags MOUSE_FOCUS          =  0x0000000000000400;
const WindowFlags EXTERNAL             =  0x0000000000000800;
const WindowFlags MODAL                =  0x0000000000001000;
const WindowFlags HIGH_PIXEL_DENSITY   =  0x0000000000002000;
const WindowFlags MOUSE_CAPTURE        =  0x0000000000004000;
const WindowFlags MOUSE_RELATIVE_MODE  =  0x0000000000008000;
const WindowFlags ALWAYS_ON_TOP        =  0x0000000000010000;
const WindowFlags UTILITY              =  0x0000000000020000;
const WindowFlags TOOLTIP              =  0x0000000000040000;
const WindowFlags POPUP_MENU           =  0x0000000000080000;
const WindowFlags KEYBOARD_GRABBED     =  0x0000000000100000;
const WindowFlags VULKAN               =  0x0000000010000000;
const WindowFlags METAL                =  0x0000000020000000;
const WindowFlags TRANSPARENT          =  0x0000000040000000;
const WindowFlags NOT_FOCUSABLE        =  0x0000000080000000;

module sdl3::window_property;

const WindowProperty CREATE_ALWAYS_ON_TOP_BOOLEAN                =  "always_on_top";
const WindowProperty CREATE_BORDERLESS_BOOLEAN                   =  "borderless";
const WindowProperty CREATE_FOCUSABLE_BOOLEAN                    =  "focusable";
const WindowProperty CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN    =  "external_graphics_context";
const WindowProperty CREATE_FULLSCREEN_BOOLEAN                   =  "fullscreen";
const WindowProperty CREATE_HEIGHT_NUMBER                        =  "height";
const WindowProperty CREATE_HIDDEN_BOOLEAN                       =  "hidden";
const WindowProperty CREATE_HIGH_PIXEL_DENSITY_BOOLEAN           =  "high_pixel_density";
const WindowProperty CREATE_MAXIMIZED_BOOLEAN                    =  "maximized";
const WindowProperty CREATE_MENU_BOOLEAN                         =  "menu";
const WindowProperty CREATE_METAL_BOOLEAN                        =  "metal";
const WindowProperty CREATE_MINIMIZED_BOOLEAN                    =  "minimized";
const WindowProperty CREATE_MODAL_BOOLEAN                        =  "modal";
const WindowProperty CREATE_MOUSE_GRABBED_BOOLEAN                =  "mouse_grabbed";
const WindowProperty CREATE_OPENGL_BOOLEAN                       =  "opengl";
const WindowProperty CREATE_PARENT_POINTER                       =  "parent";
const WindowProperty CREATE_RESIZABLE_BOOLEAN                    =  "resizable";
const WindowProperty CREATE_TITLE_STRING                         =  "title";
const WindowProperty CREATE_TRANSPARENT_BOOLEAN                  =  "transparent";
const WindowProperty CREATE_TOOLTIP_BOOLEAN                      =  "tooltip";
const WindowProperty CREATE_UTILITY_BOOLEAN                      =  "utility";
const WindowProperty CREATE_VULKAN_BOOLEAN                       =  "vulkan";
const WindowProperty CREATE_WIDTH_NUMBER                         =  "width";
const WindowProperty CREATE_X_NUMBER                             =  "x";
const WindowProperty CREATE_Y_NUMBER                             =  "y";
const WindowProperty CREATE_COCOA_WINDOW_POINTER                 =  "cocoa.window";
const WindowProperty CREATE_COCOA_VIEW_POINTER                   =  "cocoa.view";
const WindowProperty CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN  =  "wayland.surface_role_custom";
const WindowProperty CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN    =  "wayland.create_egl_window";
const WindowProperty CREATE_WAYLAND_WL_SURFACE_POINTER           =  "wayland.wl_surface";
const WindowProperty CREATE_WIN32_HWND_POINTER                   =  "win32.hwnd";
const WindowProperty CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER      =  "win32.pixel_format_hwnd";
const WindowProperty CREATE_X11_WINDOW_NUMBER                    =  "x11.window";
const WindowProperty SHAPE_POINTER                               =  "SDL.window.shape";
const WindowProperty HDR_ENABLED_BOOLEAN                         =  "SDL.window.HDR_enabled";
const WindowProperty SDR_WHITE_LEVEL_FLOAT                       =  "SDL.window.SDR_white_level";
const WindowProperty HDR_HEADROOM_FLOAT                          =  "SDL.window.HDR_headroom";
const WindowProperty ANDROID_WINDOW_POINTER                      =  "SDL.window.android.window";
const WindowProperty ANDROID_SURFACE_POINTER                     =  "SDL.window.android.surface";
const WindowProperty UIKIT_WINDOW_POINTER                        =  "SDL.window.uikit.window";
const WindowProperty UIKIT_METAL_VIEW_TAG_NUMBER                 =  "SDL.window.uikit.metal_view_tag";
const WindowProperty UIKIT_OPENGL_FRAMEBUFFER_NUMBER             =  "SDL.window.uikit.opengl.framebuffer";
const WindowProperty UIKIT_OPENGL_RENDERBUFFER_NUMBER            =  "SDL.window.uikit.opengl.renderbuffer";
const WindowProperty UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER     =  "SDL.window.uikit.opengl.resolve_framebuffer";
const WindowProperty KMSDRM_DEVICE_INDEX_NUMBER                  =  "SDL.window.kmsdrm.dev_index";
const WindowProperty KMSDRM_DRM_FD_NUMBER                        =  "SDL.window.kmsdrm.drm_fd";
const WindowProperty KMSDRM_GBM_DEVICE_POINTER                   =  "SDL.window.kmsdrm.gbm_dev";
const WindowProperty COCOA_WINDOW_POINTER                        =  "SDL.window.cocoa.window";
const WindowProperty COCOA_METAL_VIEW_TAG_NUMBER                 =  "SDL.window.cocoa.metal_view_tag";
const WindowProperty VIVANTE_DISPLAY_POINTER                     =  "SDL.window.vivante.display";
const WindowProperty VIVANTE_WINDOW_POINTER                      =  "SDL.window.vivante.window";
const WindowProperty VIVANTE_SURFACE_POINTER                     =  "SDL.window.vivante.surface";
const WindowProperty WINRT_WINDOW_POINTER                        =  "SDL.window.winrt.window";
const WindowProperty WIN32_HWND_POINTER                          =  "SDL.window.win32.hwnd";
const WindowProperty WIN32_HDC_POINTER                           =  "SDL.window.win32.hdc";
const WindowProperty WIN32_INSTANCE_POINTER                      =  "SDL.window.win32.instance";
const WindowProperty WAYLAND_DISPLAY_POINTER                     =  "SDL.window.wayland.display";
const WindowProperty WAYLAND_SURFACE_POINTER                     =  "SDL.window.wayland.surface";
const WindowProperty WAYLAND_EGL_WINDOW_POINTER                  =  "SDL.window.wayland.egl_window";
const WindowProperty WAYLAND_XDG_SURFACE_POINTER                 =  "SDL.window.wayland.xdg_surface";
const WindowProperty WAYLAND_XDG_TOPLEVEL_POINTER                =  "SDL.window.wayland.xdg_toplevel";
const WindowProperty WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING   =  "SDL.window.wayland.xdg_toplevel_export_handle";
const WindowProperty WAYLAND_XDG_POPUP_POINTER                   =  "SDL.window.wayland.xdg_popup";
const WindowProperty WAYLAND_XDG_POSITIONER_POINTER              =  "SDL.window.wayland.xdg_positioner";
const WindowProperty X11_DISPLAY_POINTER                         =  "SDL.window.x11.display";
const WindowProperty X11_SCREEN_NUMBER                           =  "SDL.window.x11.screen";
const WindowProperty X11_WINDOW_NUMBER                           =  "SDL.window.x11.window";

module sdl3::flash_operation;

const FlashOperation CANCEL         =  0;
const FlashOperation BRIEFLY        =  1;
const FlashOperation UNTIL_FOCUSED  =  2;

module sdl3::display_orientation;

const DisplayOrientation UNKNOWN            =  0;
const DisplayOrientation LANDSCAPE          =  1;
const DisplayOrientation LANDSCAPE_FLIPPED  =  2;
const DisplayOrientation PORTRAIT           =  3;
const DisplayOrientation PORTRAIT_FLIPPED   =  4;

module sdl3::system_theme;

const SystemTheme UNKNOWN  =  0;
const SystemTheme LIGHT    =  1;
const SystemTheme DARK     =  2;

module sdl3::gl_attr;

const GLattr RED_SIZE                    =  0;
const GLattr GREEN_SIZE                  =  1;
const GLattr BLUE_SIZE                   =  2;
const GLattr ALPHA_SIZE                  =  3;
const GLattr BUFFER_SIZE                 =  4;
const GLattr DOUBLEBUFFER                =  5;
const GLattr DEPTH_SIZE                  =  6;
const GLattr STENCIL_SIZE                =  7;
const GLattr ACCUM_RED_SIZE              =  8;
const GLattr ACCUM_GREEN_SIZE            =  9;
const GLattr ACCUM_BLUE_SIZE             =  10;
const GLattr ACCUM_ALPHA_SIZE            =  11;
const GLattr STEREO                      =  12;
const GLattr MULTISAMPLEBUFFERS          =  13;
const GLattr MULTISAMPLESAMPLES          =  14;
const GLattr ACCELERATED_VISUAL          =  15;
const GLattr RETAINED_BACKING            =  16;
const GLattr CONTEXT_MAJOR_VERSION       =  17;
const GLattr CONTEXT_MINOR_VERSION       =  18;
const GLattr CONTEXT_FLAGS               =  19;
const GLattr CONTEXT_PROFILE_MASK        =  20;
const GLattr SHARE_WITH_CURRENT_CONTEXT  =  21;
const GLattr FRAMEBUFFER_SRGB_CAPABLE    =  22;
const GLattr CONTEXT_RELEASE_BEHAVIOR    =  23;
const GLattr CONTEXT_RESET_NOTIFICATION  =  24;
const GLattr CONTEXT_NO_ERROR            =  25;
const GLattr FLOATBUFFERS                =  26;
const GLattr EGL_PLATFORM                =  27;

module sdl3::hit_test_result;

const HitTestResult NORMAL              =  0;
const HitTestResult DRAGGABLE           =  1;
const HitTestResult RESIZE_TOPLEFT      =  2;
const HitTestResult RESIZE_TOP          =  3;
const HitTestResult RESIZE_TOPRIGHT     =  4;
const HitTestResult RESIZE_RIGHT        =  5;
const HitTestResult RESIZE_BOTTOMRIGHT  =  6;
const HitTestResult RESIZE_BOTTOM       =  7;
const HitTestResult RESIZE_BOTTOMLEFT   =  8;
const HitTestResult RESIZE_LEFT         =  9;

module sdl3;

distinct VkAllocationCallbacks = void*;
distinct VkInstance = void*;
distinct VkPhysicalDevice = void*;
distinct VkSurfaceKHR = void*;

fn char** _vulkan_get_instance_extensions(uint* count) @extern("SDL_Vulkan_GetInstanceExtensions") @local;

macro ZString[] vulkan_get_instance_extensions()
{
    uint count;
    char** ext_names = _vulkan_get_instance_extensions(&count);

    ZString[] extensions = mem::new_array(ZString, count);
    for (int i = 0; i < count; ++i) extensions[i] = (ZString)ext_names[i];
    return extensions;
}

fn int vulkan_create_surface(Window* window, VkInstance instance, VkAllocationCallbacks* allocator, VkSurfaceKHR* surface) @extern("SDL_Vulkan_CreateSurface");
fn void vulkan_destroy_surface(VkInstance instance, VkSurfaceKHR surface, VkAllocationCallbacks* allocator) @extern("SDL_Vulkan_DestroySurface");
fn bool vulkan_get_presentation_support(VkInstance instance, VkPhysicalDevice physicalDevice, uint queueFamilyIndex) @extern("SDL_Vulkan_GetPresentationSupport");
fn FunctionPointer vulkan_get_vk_get_instance_proc_addr() @extern("SDL_Vulkan_GetVkGetInstanceProcAddr");
fn int vulkan_load_library(ZString path) @extern("SDL_Vulkan_LoadLibrary");
fn void vulkan_unload_library() @extern("SDL_Vulkan_UnloadLibrary");
